// Generated by chalk-private/engine/scripts/codegen_chalkgo_expr.py. DO NOT EDIT!
package expr

import (
	"fmt"

	"github.com/apache/arrow/go/v16/arrow"
	"github.com/apache/arrow/go/v16/arrow/array"
	"github.com/apache/arrow/go/v16/arrow/ipc"
	"github.com/apache/arrow/go/v16/arrow/memory"
	arrowv1 "github.com/chalk-ai/chalk-go/gen/chalk/arrow/v1"
	"github.com/chalk-ai/chalk-go/internal"
)

// Chalk function constructors for all supported functions
// These create function call expressions that can be used in the fluent API


// Abs Returns the absolute value of a number.
func Abs(expr Expr) Expr {
	return FunctionCall("abs", expr)
}


// Acos Calculates the inverse cosine in radians.
func Acos(expr Expr) Expr {
	return FunctionCall("acos", expr)
}


// And Performs logical AND operation on two boolean values.
func And(arg0, arg1 Expr) Expr {
	return FunctionCall("and", arg0, arg1)
}


// ArrayAdd Returns element-wise sum of two arrays.
func ArrayAdd(array1, array2 Expr) Expr {
	return FunctionCall("array_add", array1, array2)
}


// ArrayAverage Calculates the average of numeric values in an array.
func ArrayAverage(expr Expr) Expr {
	return FunctionCall("array_average", expr)
}


// ArrayConstructor Creates an array from a variable number of arguments.
func ArrayConstructor(arg0 Expr, optional ...Expr) Expr {
	args := []Expr{arg0}
	args = append(args, optional...)
	return FunctionCall("array_constructor", args...)
}



// ArrayCumSum Calculates the cumulative sum of numeric values in an array.
func ArrayCumSum(array Expr) Expr {
	return FunctionCall("array_cum_sum", array)
}


// ArrayDistinct Returns an array with duplicate elements removed, preserving order.
func ArrayDistinct(arr Expr) Expr {
	return FunctionCall("array_distinct", arr)
}


// ArrayDuplicates Returns an array containing only the duplicate elements from the input array.
func ArrayDuplicates(array Expr) Expr {
	return FunctionCall("array_duplicates", array)
}


// ArrayExcept Returns elements from the first array that are not present in the second array.
func ArrayExcept(left_array, right_array Expr) Expr {
	return FunctionCall("array_except", left_array, right_array)
}


// ArrayFilter Filters an array using a callback function predicate.
func ArrayFilter(arr, filter Expr) Expr {
	return FunctionCall("array_filter", arr, filter)
}


// ArrayFrequency Returns a map of elements to their frequency counts in an array.
func ArrayFrequency(arg0 Expr) Expr {
	return FunctionCall("array_frequency", arg0)
}


// ArrayHasDuplicates Checks if an array contains duplicate elements.
func ArrayHasDuplicates(array Expr) Expr {
	return FunctionCall("array_has_duplicates", array)
}


// ArrayIntersect Returns the intersection of two arrays (elements present in both arrays).
func ArrayIntersect(left_array, right_array Expr) Expr {
	return FunctionCall("array_intersect", left_array, right_array)
}


// ArrayJoin Joins elements of an array into a string using a separator.
func ArrayJoin(arr, delimiter Expr) Expr {
	return FunctionCall("array_join", arr, delimiter)
}


// ArrayMax Returns the maximum element in an array.
func ArrayMax(arr Expr) Expr {
	return FunctionCall("array_max", arr)
}


// ArrayMedian Calculates the median value of numeric elements in an array.
func ArrayMedian(expr Expr) Expr {
	return FunctionCall("array_median", expr)
}


// ArrayMin Returns the minimum element in an array.
func ArrayMin(arr Expr) Expr {
	return FunctionCall("array_min", arr)
}


// ArrayMode Returns the most frequently occurring element in an array.
func ArrayMode(expr Expr, tiebreak ...Expr) Expr {
	args := []Expr{expr}
	args = append(args, tiebreak...)
	return FunctionCall("array_mode", args...)
}



// ArrayMultimode Returns all most frequently occurring elements in an array.
func ArrayMultimode(arg0 Expr) Expr {
	return FunctionCall("array_multimode", arg0)
}


// ArrayNormalize Computes the L_p normalization of a Vector.
func ArrayNormalize(array, p Expr) Expr {
	return FunctionCall("array_normalize", array, p)
}


// ArrayPosition Returns the 1-based position of the first occurrence of an element in an array.
func ArrayPosition(array, element Expr) Expr {
	return FunctionCall("array_position", array, element)
}


// ArrayReduce Applies a reduce function to each element in an array and returns the accumulated value.
func ArrayReduce(arr, initial_value, arr_item_type, reduce Expr) Expr {
	return FunctionCall("array_reduce", arr, initial_value, arr_item_type, reduce)
}


// ArrayRemove Removes all occurrences of a specified element from an array.
func ArrayRemove(array, element Expr) Expr {
	return FunctionCall("array_remove", array, element)
}


// ArraySort Sorts an array in ascending order.
func ArraySort(expr Expr) Expr {
	return FunctionCall("array_sort", expr)
}


// ArraySortDesc Sorts an array in descending order.
func ArraySortDesc(arg0 Expr) Expr {
	return FunctionCall("array_sort_desc", arg0)
}


// ArrayStddev Calculates the standard deviation of numeric values in an array.
func ArrayStddev(arg0, arg1 Expr) Expr {
	return FunctionCall("array_stddev", arg0, arg1)
}


// ArraySum Calculates the sum of numeric values in an array.
func ArraySum(expr Expr) Expr {
	return FunctionCall("array_sum", expr)
}


// ArrayTransform Applies a transformation function to each element in an array and returns a new array.
func ArrayTransform(arr, transform Expr) Expr {
	return FunctionCall("array_transform", arr, transform)
}


// ArraysOverlap Checks if two arrays have any elements in common.
func ArraysOverlap(left_array, right_array Expr) Expr {
	return FunctionCall("arrays_overlap", left_array, right_array)
}


// ArraysUnion Returns a list of the distinct elements of the common elements
func ArraysUnion(arg0, arg1 Expr) Expr {
	return FunctionCall("arrays_union", arg0, arg1)
}


// Asin Calculates the inverse sine in radians.
func Asin(expr Expr) Expr {
	return FunctionCall("asin", expr)
}


// Atan Calculates the arctangent of a number in radians.
func Atan(expr Expr) Expr {
	return FunctionCall("atan", expr)
}


// Atan2 Calculates the arctangent of y/x in radians, handling quadrant correctly.
func Atan2(y, x Expr) Expr {
	return FunctionCall("atan2", y, x)
}


// BankersRound Rounds a number using banker's rounding (round half to even).
func BankersRound(value Expr, digits ...Expr) Expr {
	args := []Expr{value}
	args = append(args, digits...)
	return FunctionCall("bankers_round", args...)
}



// BetaCdf Compute the Beta cdf with given a, b parameters: P(N < value; a, b). The a, b parameters must be positive real numbers and value must be a real value (all of type DOUBLE). The value must lie on the interval [0, 1].
func BetaCdf(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("beta_cdf", arg0, arg1, arg2)
}


// Between Checks if a value is between two bounds (inclusive).
func Between(value, low, high Expr) Expr {
	return FunctionCall("between", value, low, high)
}


// BinaryToVector Returns vector from binary.
func BinaryToVector(arg0, arg1 Expr) Expr {
	return FunctionCall("binary_to_vector", arg0, arg1)
}


// BinomialCdf Compute the Binomial cdf with given numberOfTrials and successProbability (for a single trial): P(N < value). The successProbability must be real value in [0, 1], numberOfTrials and value must be positive integers with numberOfTrials greater or equal to value.
func BinomialCdf(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("binomial_cdf", arg0, arg1, arg2)
}


// BitwiseAnd Performs bitwise AND operation on two integer values.
func BitwiseAnd(left, right Expr) Expr {
	return FunctionCall("bitwise_and", left, right)
}


// BitwiseArithmeticShiftRight Returns the arithmetic right shift operation on x in 2’s complement representation. shift must not be negative.
func BitwiseArithmeticShiftRight(value, shift Expr) Expr {
	return FunctionCall("bitwise_arithmetic_shift_right", value, shift)
}


// BitwiseLeftShift Returns the left shifted value of x.
func BitwiseLeftShift(value, shift Expr) Expr {
	return FunctionCall("bitwise_left_shift", value, shift)
}


// BitwiseLogicalShiftRight Returns the logical right shift operation on x (treated as bits-bit integer) shifted by shift. shift must not be negative.
func BitwiseLogicalShiftRight(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("bitwise_logical_shift_right", arg0, arg1, arg2)
}


// BitwiseNot Performs bitwise NOT operation (complement) on an integer value.
func BitwiseNot(value Expr) Expr {
	return FunctionCall("bitwise_not", value)
}


// BitwiseOr Performs bitwise OR operation on two integer values.
func BitwiseOr(left, right Expr) Expr {
	return FunctionCall("bitwise_or", left, right)
}


// BitwiseRightShift Returns the logical right shifted value of x.
func BitwiseRightShift(value, shift Expr) Expr {
	return FunctionCall("bitwise_right_shift", value, shift)
}


// BitwiseRightShiftArithmetic Returns the arithmetic right shift value of x.
func BitwiseRightShiftArithmetic(arg0, arg1 Expr) Expr {
	return FunctionCall("bitwise_right_shift_arithmetic", arg0, arg1)
}


// BitwiseShiftLeft Returns the left shift operation on x (treated as bits-bit integer) shifted by shift. shift must not be negative.
func BitwiseShiftLeft(arg0, arg1 Expr) Expr {
	return FunctionCall("bitwise_shift_left", arg0, arg1)
}


// BitwiseXor Performs bitwise XOR operation on two integer values.
func BitwiseXor(left, right Expr) Expr {
	return FunctionCall("bitwise_xor", left, right)
}


// BoostRegexpFindall Finds all matches of a regular expression pattern in a string and returns them as a list.
func BoostRegexpFindall(arg0, arg1 Expr) Expr {
	return FunctionCall("boost_regexp_findall", arg0, arg1)
}


// BytesToStringBase64 Encodes binary into a base64 string representation.
func BytesToStringBase64(arg0 Expr) Expr {
	return FunctionCall("bytes_to_string_base64", arg0)
}


// BytesToStringHex Encodes binary into a base64 string representation.
func BytesToStringHex(arg0 Expr) Expr {
	return FunctionCall("bytes_to_string_hex", arg0)
}


// BytesToStringUtf8 Encodes binary into a base64 string representation.
func BytesToStringUtf8(arg0 Expr) Expr {
	return FunctionCall("bytes_to_string_utf8", arg0)
}


// Cardinality Returns the number of elements in a list.
func Cardinality(arr Expr) Expr {
	return FunctionCall("cardinality", arr)
}


// CauchyCdf Compute the Cauchy cdf with given parameters median and scale (gamma): P(N; median, scale). The scale parameter must be a positive double. The value parameter must be a double on the interval [0, 1].
func CauchyCdf(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("cauchy_cdf", arg0, arg1, arg2)
}


// Cbrt Calculates the cube root of a number.
func Cbrt(expr Expr) Expr {
	return FunctionCall("cbrt", expr)
}


// Ceil Returns the smallest integer greater than or equal to the given number.
func Ceil(expr Expr) Expr {
	return FunctionCall("ceil", expr)
}


// Ceiling Returns the smallest integer greater than or equal to the given number.
func Ceiling(arg0 Expr) Expr {
	return FunctionCall("ceiling", arg0)
}


// ChiSquaredCdf Compute the Chi-square cdf with given df (degrees of freedom) parameter: P(N < value; df). The df parameter must be a positive real number, and value must be a non-negative real value (both of type DOUBLE).
func ChiSquaredCdf(arg0, arg1 Expr) Expr {
	return FunctionCall("chi_squared_cdf", arg0, arg1)
}


// Chr Converts an integer to its corresponding ASCII character.
func Chr(code Expr) Expr {
	return FunctionCall("chr", code)
}


// Clamp Constrains a value between a minimum and maximum range.
func Clamp(expr, min_val, max_val Expr) Expr {
	return FunctionCall("clamp", expr, min_val, max_val)
}


// Coalesce Returns the first non-null value from a list of arguments.
func Coalesce(vals Expr, optional ...Expr) Expr {
	args := []Expr{vals}
	args = append(args, optional...)
	return FunctionCall("coalesce", args...)
}



// Codepoint Returns the Unicode code point of the only character of the string.
func Codepoint(arg0 Expr) Expr {
	return FunctionCall("codepoint", arg0)
}


// Concat Concatenates two or more strings together.
func Concat(first, second Expr, optional ...Expr) Expr {
	args := []Expr{first, second}
	args = append(args, optional...)
	return FunctionCall("concat", args...)
}



// Contains Checks if a list contains a specific element.
func Contains(arr, value Expr) Expr {
	return FunctionCall("contains", arr, value)
}


// Cos Calculates the cosine of an angle in radians.
func Cos(expr Expr) Expr {
	return FunctionCall("cos", expr)
}


// Cosh Calculates the hyperbolic cosine of a number.
func Cosh(expr Expr) Expr {
	return FunctionCall("cosh", expr)
}


// CosineSimilarityVector Returns the cosine similarity between the vectors.
func CosineSimilarityVector(arg0, arg1 Expr) Expr {
	return FunctionCall("cosine_similarity_vector", arg0, arg1)
}


// Crc32 Calculates the CRC32 checksum of binary data.
func Crc32(arg0 Expr) Expr {
	return FunctionCall("crc32", arg0)
}


// CurrentDate Returns the current date.
func CurrentDate() Expr {
	return FunctionCall("current_date")
}


// DateAdd date + duration addition
func DateAdd(arg0, arg1 Expr) Expr {
	return FunctionCall("date_add", arg0, arg1)
}


// DateTrunc Truncates a timestamp to the specified time unit (e.g., day, month, year).
func DateTrunc(expr, unit Expr) Expr {
	return FunctionCall("date_trunc", expr, unit)
}


// DayOfMonth Extracts the day of the month from a timestamp.
func DayOfMonth(expr Expr) Expr {
	return FunctionCall("day_of_month", expr)
}


// DayOfWeek Extracts the day of the week from a timestamp.
func DayOfWeek(expr Expr) Expr {
	return FunctionCall("day_of_week", expr)
}


// DayOfYear Extracts the day of the month from a timestamp.
func DayOfYear(expr Expr) Expr {
	return FunctionCall("day_of_year", expr)
}


// Degrees Converts radians to degrees.
func Degrees(expr Expr) Expr {
	return FunctionCall("degrees", expr)
}


// DistinctFrom Checks if two values are distinct, treating NULL values as different from non-NULL values.
func DistinctFrom(value1, value2 Expr) Expr {
	return FunctionCall("distinct_from", value1, value2)
}


// DotProductVector Returns the dot product between the vectors.
func DotProductVector(arg0, arg1 Expr) Expr {
	return FunctionCall("dot_product_vector", arg0, arg1)
}


// E Returns the mathematical constant e (Euler's number).
func E() Expr {
	return FunctionCall("e")
}


// ElementAt Returns the element at the specified index in a list.
func ElementAt(arr, index Expr) Expr {
	return FunctionCall("element_at", arr, index)
}


// EndsWith Checks if a string ends with a specified suffix.
func EndsWith(expr, suffix Expr) Expr {
	return FunctionCall("ends_with", expr, suffix)
}


// Eq eq
func Eq(arg0, arg1 Expr) Expr {
	return FunctionCall("eq", arg0, arg1)
}


// Exp Calculates e raised to the power of a number.
func Exp(expr Expr) Expr {
	return FunctionCall("exp", expr)
}


// FCdf Compute the F cdf with given df1 (numerator degrees of freedom) and df2 (denominator degrees of freedom) parameters: P(N < value; df1, df2). The numerator and denominator df parameters must be positive real numbers. The value must be a non-negative real number.
func FCdf(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("f_cdf", arg0, arg1, arg2)
}


// Fail Raises an error with the specified error message.
func Fail(arg0 Expr) Expr {
	return FunctionCall("fail", arg0)
}


// FindFirst Returns the first element in an array that matches the given predicate function.
func FindFirst(arg0, arg1 Expr) Expr {
	return FunctionCall("find_first", arg0, arg1)
}


// FindFirstIndex Returns the 1-based index of the first element in an array that matches the given predicate function.
func FindFirstIndex(arg0, arg1 Expr) Expr {
	return FunctionCall("find_first_index", arg0, arg1)
}


// Flatten Flattens a nested array by one level, combining all sub-arrays into a single array.
func Flatten(array Expr) Expr {
	return FunctionCall("flatten", array)
}


// Floor Returns the largest integer less than or equal to the given number.
func Floor(expr Expr) Expr {
	return FunctionCall("floor", expr)
}


// FormatDatetime Formats a datetime using a specified format string.
func FormatDatetime(input_dt, format Expr) Expr {
	return FunctionCall("format_datetime", input_dt, format)
}


// FromBase Converts a string representation of a number in a given base to an integer.
func FromBase(value, base Expr) Expr {
	return FunctionCall("from_base", value, base)
}


// FromBase64 Decodes a Base64-encoded string to binary data.
func FromBase64(arg0 Expr) Expr {
	return FunctionCall("from_base64", arg0)
}


// FromBase64Url Decodes a Base64url-encoded string to binary data.
func FromBase64Url(arg0 Expr) Expr {
	return FunctionCall("from_base64url", arg0)
}


// FromBigEndian32 Convert a 32-bit big-endian bytes value to an integer.
func FromBigEndian32(expr Expr) Expr {
	return FunctionCall("from_big_endian_32", expr)
}


// FromBigEndian64 Convert a 64-bit big-endian bytes value to an integer.
func FromBigEndian64(expr Expr) Expr {
	return FunctionCall("from_big_endian_64", expr)
}


// FromHex Converts a hexadecimal string to binary data.
func FromHex(arg0 Expr) Expr {
	return FunctionCall("from_hex", arg0)
}


// FromIso8601Timestamp Parses an ISO 8601 timestamp string into a datetime object.
func FromIso8601Timestamp(expr Expr) Expr {
	return FunctionCall("from_iso8601_timestamp", expr)
}


// FromUnixSeconds Converts Unix timestamp (seconds since epoch) to a timestamp.
func FromUnixSeconds(expr Expr) Expr {
	return FunctionCall("from_unix_seconds", expr)
}


// FromUnixtime Returns the UNIX timestamp unixtime as a timestamp with time zone using hours and minutes for the time zone offset.
func FromUnixtime(arg0 Expr, arg1 ...Expr) Expr {
	args := []Expr{arg0}
	args = append(args, arg1...)
	return FunctionCall("from_unixtime", args...)
}



// FromUtf8 Decodes UTF-8 encoded binary data into a string.
func FromUtf8(arg0 Expr) Expr {
	return FunctionCall("from_utf8", arg0)
}


// GammaCdf Compute the Gamma cdf with given shape and scale parameters: P(N < value; shape, scale). The shape and scale parameters must be positive real numbers. The value must be a non-negative real number.
func GammaCdf(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("gamma_cdf", arg0, arg1, arg2)
}


// Greatest Returns the maximum value from a list of float values.
func Greatest(arg0 Expr, optional ...Expr) Expr {
	args := []Expr{arg0}
	args = append(args, optional...)
	return FunctionCall("greatest", args...)
}



// Gt gt
func Gt(arg0, arg1 Expr) Expr {
	return FunctionCall("gt", arg0, arg1)
}


// Gte gte
func Gte(arg0, arg1 Expr) Expr {
	return FunctionCall("gte", arg0, arg1)
}


// Gunzip gunzip the input binary data.
func Gunzip(expr Expr) Expr {
	return FunctionCall("gunzip", expr)
}


// H3CellToLatLonDegrees Calculates the lat-lon in degrees for a given h3 cell.
func H3CellToLatLonDegrees(arg0 Expr) Expr {
	return FunctionCall("h3_cell_to_lat_lon_degrees", arg0)
}


// H3CellToLatLonRadians Calculates the lat-lon for a given h3 cell.
func H3CellToLatLonRadians(arg0 Expr) Expr {
	return FunctionCall("h3_cell_to_lat_lon_radians", arg0)
}


// H3LatLonToCell Calculates the h3 cell for a given lat-lon.
func H3LatLonToCell(lat, lon, resolution Expr) Expr {
	return FunctionCall("h3_lat_lon_to_cell", lat, lon, resolution)
}


// HammingDistance Returns the Hamming distance of string1 and string2, i.e. the number of positions at which the corresponding characters are different. Note that the two strings must have the same length.
func HammingDistance(arg0, arg1 Expr) Expr {
	return FunctionCall("hamming_distance", arg0, arg1)
}


// HmacMd5 Computes HMAC-MD5 authentication code for data using a secret key.
func HmacMd5(arg0, arg1 Expr) Expr {
	return FunctionCall("hmac_md5", arg0, arg1)
}


// HmacSha1 Computes HMAC-SHA1 authentication code for data using a secret key.
func HmacSha1(arg0, arg1 Expr) Expr {
	return FunctionCall("hmac_sha1", arg0, arg1)
}


// HmacSha256 Computes HMAC-SHA256 authentication code for data using a secret key.
func HmacSha256(arg0, arg1 Expr) Expr {
	return FunctionCall("hmac_sha256", arg0, arg1)
}


// HmacSha512 Computes HMAC-SHA512 authentication code for data using a secret key.
func HmacSha512(arg0, arg1 Expr) Expr {
	return FunctionCall("hmac_sha512", arg0, arg1)
}


// Hour Extracts the hour from a timestamp.
func Hour(arg0 Expr) Expr {
	return FunctionCall("hour", arg0)
}


// HttpRequest Makes an HTTP request with string body and returns the response as bytes.
func HttpRequest(url, method, headers, body, allow_redirects, timeout Expr) Expr {
	return FunctionCall("http_request", url, method, headers, body, allow_redirects, timeout)
}


// IfElse Returns the second argument if the condition is true, otherwise returns the third argument.
func IfElse(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("if_else", arg0, arg1, arg2)
}


// InverseBetaCdf Compute the inverse of the Beta cdf with given a, b parameters for the cumulative probability (p): P(N < n). The a, b parameters must be positive double values. The probability p must lie on the interval [0, 1].
func InverseBetaCdf(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("inverse_beta_cdf", arg0, arg1, arg2)
}


// InverseBinomialCdf Compute the inverse of the Binomial cdf with given numberOfTrials and successProbability (of a single trial) the cumulative probability (p): P(N <= n). The successProbability and p must be real values in [0, 1] and the numberOfTrials must be a positive integer.
func InverseBinomialCdf(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("inverse_binomial_cdf", arg0, arg1, arg2)
}


// InverseCauchyCdf Compute the inverse of the Cauchy cdf with given parameters median and scale (gamma) for the probability p. The scale parameter must be a positive double. The probability p must be a double on the interval [0, 1].
func InverseCauchyCdf(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("inverse_cauchy_cdf", arg0, arg1, arg2)
}


// InverseChiSquaredCdf Compute the inverse of the Chi-square cdf with given df (degrees of freedom) parameter for the cumulative probability (p): P(N < n). The df parameter must be positive real values. The probability p must lie on the interval [0, 1].
func InverseChiSquaredCdf(arg0, arg1 Expr) Expr {
	return FunctionCall("inverse_chi_squared_cdf", arg0, arg1)
}


// InverseFCdf Compute the inverse of the Fisher F cdf with a given df1 (numerator degrees of freedom) and df2 (denominator degrees of freedom) parameters for the cumulative probability (p): P(N < n). The numerator and denominator df parameters must be positive real numbers. The probability p must lie on the interval [0, 1].
func InverseFCdf(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("inverse_f_cdf", arg0, arg1, arg2)
}


// InverseGammaCdf Compute the inverse of the Gamma cdf with given shape and scale parameters for the cumulative probability (p): P(N < n). The shape and scale parameters must be positive real values. The probability p must lie on the interval [0, 1].
func InverseGammaCdf(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("inverse_gamma_cdf", arg0, arg1, arg2)
}


// InverseLaplaceCdf Compute the inverse of the Laplace cdf with given mean and scale parameters for the cumulative probability (p): P(N < n). The mean must be a real value and the scale must be a positive real value (both of type DOUBLE). The probability p must lie on the interval [0, 1].
func InverseLaplaceCdf(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("inverse_laplace_cdf", arg0, arg1, arg2)
}


// InverseNormalCdf Compute the inverse of the Normal cdf with given mean and standard deviation (sd) for the cumulative probability (p): P(N < n). The mean must be a real value and the standard deviation must be a real and positive value (both of type DOUBLE). The probability p must lie on the interval (0, 1).
func InverseNormalCdf(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("inverse_normal_cdf", arg0, arg1, arg2)
}


// InversePoissonCdf Compute the inverse of the Poisson cdf with given lambda (mean) parameter for the cumulative probability (p). It returns the value of n so that: P(N <= n; lambda) = p. The lambda parameter must be a positive real number (of type DOUBLE). The probability p must lie on the interval [0, 1).
func InversePoissonCdf(arg0, arg1 Expr) Expr {
	return FunctionCall("inverse_poisson_cdf", arg0, arg1)
}


// InverseWeibullCdf Compute the inverse of the Weibull cdf with given parameters a, b for the probability p. The a, b parameters must be positive double values. The probability p must be a double on the interval [0, 1].
func InverseWeibullCdf(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("inverse_weibull_cdf", arg0, arg1, arg2)
}


// IsFederalHoliday Returns True if the given timestamp is a federal holiday.
func IsFederalHoliday(arg0 Expr) Expr {
	return FunctionCall("is_federal_holiday", arg0)
}


// IsFinite Checks if a floating-point number is finite (not NaN or infinite).
func IsFinite(arg0 Expr) Expr {
	return FunctionCall("is_finite", arg0)
}


// IsInfinite Checks if a floating-point number is infinite.
func IsInfinite(arg0 Expr) Expr {
	return FunctionCall("is_infinite", arg0)
}


// IsNan Checks if a floating-point number is NaN (Not a Number).
func IsNan(arg0 Expr) Expr {
	return FunctionCall("is_nan", arg0)
}


// IsNull Checks if the input is null.
func IsNull(expr Expr) Expr {
	return FunctionCall("is_null", expr)
}


// JaccardSimilarity Calculates the Jaccard similarity coefficient between two strings based on character sets.
func JaccardSimilarity(a, b Expr) Expr {
	return FunctionCall("jaccard_similarity", a, b)
}


// JaroWinklerDistance Calculates the Jaro-Winkler distance between two strings.
func JaroWinklerDistance(a, b, prefix_weight Expr) Expr {
	return FunctionCall("jaro_winkler_distance", a, b, prefix_weight)
}


// Jinja Renders a Jinja2 template string with provided context variables.
func Jinja(arg0, arg1 Expr) Expr {
	return FunctionCall("jinja", arg0, arg1)
}


// JsonExtractArray Extracts an array from JSON string using a path expression.
func JsonExtractArray(expr, path Expr) Expr {
	return FunctionCall("json_extract_array", expr, path)
}


// Jsonify Converts an arbitrary value into a JSON string
func Jsonify(expr Expr) Expr {
	return FunctionCall("jsonify", expr)
}


// LaplaceCdf Compute the Laplace cdf with given mean and scale parameters: P(N < value; mean, scale). The mean and value must be real values and the scale parameter must be a positive value (all of type DOUBLE).
func LaplaceCdf(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("laplace_cdf", arg0, arg1, arg2)
}


// LastDayOfMonth Returns the last day of the month for a given date.
func LastDayOfMonth(expr Expr) Expr {
	return FunctionCall("last_day_of_month", expr)
}


// Least Returns the minimum value from a list of float values.
func Least(arg0 Expr, optional ...Expr) Expr {
	args := []Expr{arg0}
	args = append(args, optional...)
	return FunctionCall("least", args...)
}



// Length Returns the length of a string in characters.
func Length(expr Expr) Expr {
	return FunctionCall("length", expr)
}


// LevenshteinDistance Calculates the Levenshtein distance between two strings.
func LevenshteinDistance(a, b Expr) Expr {
	return FunctionCall("levenshtein_distance", a, b)
}


// Like Checks if a string matches a pattern using SQL LIKE syntax with wildcards.
func Like(expr, pattern Expr) Expr {
	return FunctionCall("like", expr, pattern)
}


// Ln Calculates the natural logarithm of a number.
func Ln(expr Expr) Expr {
	return FunctionCall("ln", expr)
}


// Log Calculates the natural logarithm of a number.
func Log(arg0 Expr) Expr {
	return FunctionCall("log", arg0)
}


// Log10 Calculates the base-10 logarithm of a number.
func Log10(expr Expr) Expr {
	return FunctionCall("log10", expr)
}


// Log2 Calculates the base-2 logarithm of a number.
func Log2(expr Expr) Expr {
	return FunctionCall("log2", expr)
}


// LongestCommonSubsequence Calculates the longest common subsequence between two strings.
func LongestCommonSubsequence(a, b Expr) Expr {
	return FunctionCall("longest_common_subsequence", a, b)
}


// Lower Converts a string to lowercase.
func Lower(expr Expr) Expr {
	return FunctionCall("lower", expr)
}


// Lpad Pads a string with a specified padding string on the left to reach a target length.
func Lpad(string, size, padstring Expr) Expr {
	return FunctionCall("lpad", string, size, padstring)
}


// Lt lt
func Lt(arg0, arg1 Expr) Expr {
	return FunctionCall("lt", arg0, arg1)
}


// Lte lte
func Lte(arg0, arg1 Expr) Expr {
	return FunctionCall("lte", arg0, arg1)
}


// Ltrim Removes whitespace from the left end of a string.
func Ltrim(expr Expr, optional ...Expr) Expr {
	args := []Expr{expr}
	args = append(args, optional...)
	return FunctionCall("ltrim", args...)
}



// MapContains Checks if a map contains any keys that match a given condition.
func MapContains(arg0, arg1 Expr) Expr {
	return FunctionCall("map_contains", arg0, arg1)
}


// MapGet Retrieves the value associated with a key from a map.
func MapGet(mapping, key Expr) Expr {
	return FunctionCall("map_get", mapping, key)
}


// MapKeysByTopNValues Returns the keys of a map ordered by their top N highest values.
func MapKeysByTopNValues(arg0, arg1 Expr) Expr {
	return FunctionCall("map_keys_by_top_n_values", arg0, arg1)
}


// Md5 Computes the MD5 hash of binary data.
func Md5(expr Expr) Expr {
	return FunctionCall("md5", expr)
}


// Millisecond Extracts the millisecond from a timestamp.
func Millisecond(arg0 Expr) Expr {
	return FunctionCall("millisecond", arg0)
}


// Minute Extracts the minute from a timestamp.
func Minute(arg0 Expr) Expr {
	return FunctionCall("minute", arg0)
}


// Month Extracts the month from a timestamp.
func Month(arg0 Expr) Expr {
	return FunctionCall("month", arg0)
}


// Nan Returns a floating point NaN (Not a Number) value.
func Nan() Expr {
	return FunctionCall("nan")
}


// Negate Returns the negative value of a number.
func Negate(arg0 Expr) Expr {
	return FunctionCall("negate", arg0)
}


// Neq neq
func Neq(arg0, arg1 Expr) Expr {
	return FunctionCall("neq", arg0, arg1)
}


// NormalCdf Compute the Normal cdf with given mean and standard deviation (sd): P(N < value; mean, sd). The mean and value must be real values and the standard deviation must be a real and positive value (all of type DOUBLE).
func NormalCdf(x, mean, std_dev Expr) Expr {
	return FunctionCall("normal_cdf", x, mean, std_dev)
}


// OpenaiComplete Makes a completion request to OpenAI's chat API and returns the response.
func OpenaiComplete(api_key, prompt, model, max_tokens, temperature Expr) Expr {
	return FunctionCall("openai_complete", api_key, prompt, model, max_tokens, temperature)
}


// ParseDatetime Converts an ISO 8601 string into a datetime.
func ParseDatetime(expr, format Expr) Expr {
	return FunctionCall("parse_datetime", expr, format)
}


// PartialRatio Calculates the partial ratio similarity between two strings using fuzzy matching.
func PartialRatio(a, b Expr) Expr {
	return FunctionCall("partial_ratio", a, b)
}


// Pi Returns the mathematical constant π (pi).
func Pi() Expr {
	return FunctionCall("pi")
}


// PoissonCdf Compute the Poisson cdf with given lambda (mean) parameter: P(N <= value; lambda). The lambda parameter must be a positive real number (of type DOUBLE) and value must be a non-negative integer.
func PoissonCdf(arg0, arg1 Expr) Expr {
	return FunctionCall("poisson_cdf", arg0, arg1)
}


// Pow Raises a number to the power of another number.
func Pow(base, exponent Expr) Expr {
	return FunctionCall("pow", base, exponent)
}


// Power Raises the first number to the power of the second number.
func Power(a, b Expr) Expr {
	return FunctionCall("power", a, b)
}


// ProtoDeserialize Converts protobuf binary data to a structured format.
func ProtoDeserialize(arg0, arg1, arg2, arg3 Expr) Expr {
	return FunctionCall("proto_deserialize", arg0, arg1, arg2, arg3)
}


// ProtoSerialize Converts protobuf binary data to a structured format.
func ProtoSerialize(arg0, arg1, arg2, arg3 Expr) Expr {
	return FunctionCall("proto_serialize", arg0, arg1, arg2, arg3)
}


// ProtoToStruct Converts protobuf binary data to a structured format.
func ProtoToStruct(arg0, arg1, arg2, arg3 Expr) Expr {
	return FunctionCall("proto_to_struct", arg0, arg1, arg2, arg3)
}


// Quarter Extracts the quarter of the year from a timestamp.
func Quarter(expr Expr) Expr {
	return FunctionCall("quarter", expr)
}


// Radians Converts degrees to radians.
func Radians(expr Expr) Expr {
	return FunctionCall("radians", expr)
}


// Rand Generates a random float between 0 and 1.
func Rand() Expr {
	return FunctionCall("rand")
}


// Random Generates a pseudo-random float between 0 and 1.
func Random(n ...Expr) Expr {
	return FunctionCall("random", n...)
}



// Recover Return the first valid entry. Functions like coalesce, but allows recovering from an upstream failure
func Recover(vals Expr, optional ...Expr) Expr {
	args := []Expr{vals}
	args = append(args, optional...)
	return FunctionCall("recover", args...)
}



// RegexpExtract Returns the first substring matched by the regular expression pattern in string.
func RegexpExtract(expr, pattern Expr, group ...Expr) Expr {
	args := []Expr{expr, pattern}
	args = append(args, group...)
	return FunctionCall("regexp_extract", args...)
}



// RegexpExtractAll Returns the substring(s) matched by the regular expression pattern in string.
func RegexpExtractAll(expr, pattern Expr, group ...Expr) Expr {
	args := []Expr{expr, pattern}
	args = append(args, group...)
	return FunctionCall("regexp_extract_all", args...)
}



// RegexpLike Checks if a string matches a regular expression pattern.
func RegexpLike(expr, pattern Expr) Expr {
	return FunctionCall("regexp_like", expr, pattern)
}


// RegexpReplace Replaces all matches of a regular expression pattern with a replacement string.
func RegexpReplace(expr, pattern Expr, replacement ...Expr) Expr {
	args := []Expr{expr, pattern}
	args = append(args, replacement...)
	return FunctionCall("regexp_replace", args...)
}



// RegexpSplit Splits a string by a regex pattern into a list of strings.
func RegexpSplit(expr, pattern Expr) Expr {
	return FunctionCall("regexp_split", expr, pattern)
}


// RemoveNulls Removes all null values from an array.
func RemoveNulls(array Expr) Expr {
	return FunctionCall("remove_nulls", array)
}


// Replace Replaces all occurrences of a substring with another string.
func Replace(expr, old, new Expr) Expr {
	return FunctionCall("replace", expr, old, new)
}


// Reverse Reverses the characters in a string.
func Reverse(expr Expr) Expr {
	return FunctionCall("reverse", expr)
}


// Round Rounds a floating point number to the nearest integer.
func Round(value Expr, digits ...Expr) Expr {
	args := []Expr{value}
	args = append(args, digits...)
	return FunctionCall("round", args...)
}



// Rpad Pads a string with a specified padding string on the right to reach a target length.
func Rpad(string, size, padstring Expr) Expr {
	return FunctionCall("rpad", string, size, padstring)
}


// Rtrim Removes whitespace from the right end of a string.
func Rtrim(expr Expr, optional ...Expr) Expr {
	args := []Expr{expr}
	args = append(args, optional...)
	return FunctionCall("rtrim", args...)
}



// ScalarMax Returns the maximum of two scalar values.
func ScalarMax(arg0, arg1 Expr) Expr {
	return FunctionCall("scalar_max", arg0, arg1)
}


// ScalarMin Returns the minimum of two scalar values.
func ScalarMin(arg0, arg1 Expr) Expr {
	return FunctionCall("scalar_min", arg0, arg1)
}


// ScaleVector Returns a scaled vector.
func ScaleVector(array, p Expr) Expr {
	return FunctionCall("scale_vector", array, p)
}


// Second Extracts the second from a timestamp.
func Second(arg0 Expr) Expr {
	return FunctionCall("second", arg0)
}


// SecureRandom Generates a cryptographically secure random float between 0 and 1.
func SecureRandom(min_val ...Expr) Expr {
	return FunctionCall("secure_random", min_val...)
}



// Sequence Generates a sequence of integers from start to stop (inclusive).
func Sequence(start, stop Expr, step ...Expr) Expr {
	args := []Expr{start, stop}
	args = append(args, step...)
	return FunctionCall("sequence", args...)
}



// SequenceMatcherRatio Computes the similarity ratio between two strings using sequence matching.
func SequenceMatcherRatio(a, b Expr) Expr {
	return FunctionCall("sequence_matcher_ratio", a, b)
}


// Sha1 Computes the SHA-1 hash of binary data.
func Sha1(expr Expr) Expr {
	return FunctionCall("sha1", expr)
}


// Sha256 Computes the SHA-256 hash of binary data.
func Sha256(expr Expr) Expr {
	return FunctionCall("sha256", expr)
}


// Sha512 Computes the SHA-512 hash of binary data.
func Sha512(expr Expr) Expr {
	return FunctionCall("sha512", expr)
}


// Shuffle Randomly shuffles the elements of an array.
func Shuffle(array Expr) Expr {
	return FunctionCall("shuffle", array)
}


// Sign Returns the sign of a number (-1, 0, or 1).
func Sign(expr Expr) Expr {
	return FunctionCall("sign", expr)
}


// Sin Calculates the sine of an angle in radians.
func Sin(expr Expr) Expr {
	return FunctionCall("sin", expr)
}


// Slice Returns a slice of a list starting at the given position for the specified length.
func Slice(arr, offset, length Expr) Expr {
	return FunctionCall("slice", arr, offset, length)
}


// Split Splits a string by a delimiter into a list of strings.
func Split(expr, delimiter Expr, maxsplit ...Expr) Expr {
	args := []Expr{expr, delimiter}
	args = append(args, maxsplit...)
	return FunctionCall("split", args...)
}



// SplitPart Splits a string by delimiter and returns the part at the specified index (1-based).
func SplitPart(expr, delimiter, index Expr) Expr {
	return FunctionCall("split_part", expr, delimiter, index)
}


// SpookyHashV232 Computes a 32-bit SpookyHash V2 hash of binary data.
func SpookyHashV232(expr Expr) Expr {
	return FunctionCall("spooky_hash_v2_32", expr)
}


// SpookyHashV264 Computes a 64-bit SpookyHash V2 hash of binary data.
func SpookyHashV264(expr Expr) Expr {
	return FunctionCall("spooky_hash_v2_64", expr)
}


// Sqrt Calculates the square root of a number.
func Sqrt(expr Expr) Expr {
	return FunctionCall("sqrt", expr)
}


// StartsWith Checks if a string starts with a specified prefix.
func StartsWith(expr, prefix Expr) Expr {
	return FunctionCall("starts_with", expr, prefix)
}


// StringToBytesBase64 Decodes a Base64-encoded string back into its original binary form. This function is capable of handling both fully padded and non-padded Base64 encoded strings. Partially padded Base64 strings are not supported and will result in a “UserError” status being returned.
func StringToBytesBase64(arg0 Expr) Expr {
	return FunctionCall("string_to_bytes_base64", arg0)
}


// StringToBytesHex Decodes binary data from the hex encoded string.
func StringToBytesHex(arg0 Expr) Expr {
	return FunctionCall("string_to_bytes_hex", arg0)
}


// StringToBytesUtf8 Encodes string into a UTF-8 varbinary representation.
func StringToBytesUtf8(arg0 Expr) Expr {
	return FunctionCall("string_to_bytes_utf8", arg0)
}


// Strpos Returns the position of the first occurrence of a substring within a string.
func Strpos(expr, substring Expr) Expr {
	return FunctionCall("strpos", expr, substring)
}


// Strrpos Returns the position of the last occurrence of a substring within a string.
func Strrpos(expr, substring Expr) Expr {
	return FunctionCall("strrpos", expr, substring)
}


// StructToProto Converts structured data to protobuf binary format.
func StructToProto(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("struct_to_proto", arg0, arg1, arg2)
}


// Substr Returns a substring starting at the specified position.
func Substr(expr, start Expr, length ...Expr) Expr {
	args := []Expr{expr, start}
	args = append(args, length...)
	return FunctionCall("substr", args...)
}



// Tan Calculates the tangent of an angle in radians.
func Tan(arg0 Expr) Expr {
	return FunctionCall("tan", arg0)
}


// Tanh Calculates the hyperbolic tangent of a number.
func Tanh(expr Expr) Expr {
	return FunctionCall("tanh", expr)
}


// ToBase Converts an integer to its string representation in the specified base.
func ToBase(number, base Expr) Expr {
	return FunctionCall("to_base", number, base)
}


// ToBase64 Encodes binary data to a Base64 string.
func ToBase64(arg0 Expr) Expr {
	return FunctionCall("to_base64", arg0)
}


// ToBase64Url Encodes binary data to a Base64url string.
func ToBase64Url(arg0 Expr) Expr {
	return FunctionCall("to_base64url", arg0)
}


// ToHex Converts binary data to its hexadecimal string representation.
func ToHex(arg0 Expr) Expr {
	return FunctionCall("to_hex", arg0)
}


// ToIso8601 Converts a datetime to an ISO 8601 string format.
func ToIso8601(expr Expr) Expr {
	return FunctionCall("to_iso8601", expr)
}


// ToMicroseconds Converts a duration to microseconds.
func ToMicroseconds(arg0 Expr) Expr {
	return FunctionCall("to_microseconds", arg0)
}


// ToMilliseconds Converts a duration to milliseconds.
func ToMilliseconds(arg0 Expr) Expr {
	return FunctionCall("to_milliseconds", arg0)
}


// ToUnixtime Converts a timestamp to Unix timestamp (seconds since epoch).
func ToUnixtime(arg0 Expr) Expr {
	return FunctionCall("to_unixtime", arg0)
}


// ToUtf8 Encodes a string to UTF-8 binary data.
func ToUtf8(arg0 Expr) Expr {
	return FunctionCall("to_utf8", arg0)
}


// TokenSetRatio Calculates the token set ratio similarity between two strings using fuzzy matching.
func TokenSetRatio(a, b Expr) Expr {
	return FunctionCall("token_set_ratio", a, b)
}


// TokenSortRatio Calculates the token sort ratio similarity between two strings using fuzzy matching.
func TokenSortRatio(a, b Expr) Expr {
	return FunctionCall("token_sort_ratio", a, b)
}


// TotalSeconds Returns the length of the input duration in seconds.
func TotalSeconds(delta Expr) Expr {
	return FunctionCall("total_seconds", delta)
}


// Trail Returns the last N characters of the input string up to at most the length of string.
func Trail(arg0, arg1 Expr) Expr {
	return FunctionCall("trail", arg0, arg1)
}


// Transform Applies a transformation function to each element in an array and returns a new array.
func Transform(arg0, arg1 Expr) Expr {
	return FunctionCall("transform", arg0, arg1)
}


// Trim Removes whitespace from both ends of a string.
func Trim(expr Expr, optional ...Expr) Expr {
	args := []Expr{expr}
	args = append(args, optional...)
	return FunctionCall("trim", args...)
}



// Truncate Truncates a floating-point number to remove the decimal part.
func Truncate(arg0 Expr) Expr {
	return FunctionCall("truncate", arg0)
}


// Try Attempts to execute an expression and handles any errors gracefully.
func Try(arg0 Expr) Expr {
	return FunctionCall("try_", arg0)
}


// UnidecodeNormalize Normalizes Unicode characters to their closest ASCII equivalents with whitespace normalization.
func UnidecodeNormalize(a Expr) Expr {
	return FunctionCall("unidecode_normalize", a)
}


// UnidecodeToAscii Converts Unicode characters to their closest ASCII equivalents.
func UnidecodeToAscii(a Expr) Expr {
	return FunctionCall("unidecode_to_ascii", a)
}


// Upper Converts a string to uppercase.
func Upper(expr Expr) Expr {
	return FunctionCall("upper", expr)
}


// UrlDecode Decodes URL-encoded characters in a string.
func UrlDecode(arg0 Expr) Expr {
	return FunctionCall("url_decode", arg0)
}


// UrlEncode URL-encodes special characters in a string.
func UrlEncode(arg0 Expr) Expr {
	return FunctionCall("url_encode", arg0)
}


// UrlExtractFragment Extracts the fragment portion (after #) from a URL.
func UrlExtractFragment(arg0 Expr) Expr {
	return FunctionCall("url_extract_fragment", arg0)
}


// UrlExtractHost Returns the host from a URL.
func UrlExtractHost(expr Expr) Expr {
	return FunctionCall("url_extract_host", expr)
}


// UrlExtractParameter Extracts the value of a specific query parameter from a URL.
func UrlExtractParameter(arg0, arg1 Expr) Expr {
	return FunctionCall("url_extract_parameter", arg0, arg1)
}


// UrlExtractPath Returns the path from a URL.
func UrlExtractPath(expr Expr) Expr {
	return FunctionCall("url_extract_path", expr)
}


// UrlExtractPort Extracts the port number from a URL.
func UrlExtractPort(arg0 Expr) Expr {
	return FunctionCall("url_extract_port", arg0)
}


// UrlExtractProtocol Returns the protocol from a URL.
func UrlExtractProtocol(expr Expr) Expr {
	return FunctionCall("url_extract_protocol", expr)
}


// UrlExtractQuery Extracts the query string portion (after ?) from a URL.
func UrlExtractQuery(arg0 Expr) Expr {
	return FunctionCall("url_extract_query", arg0)
}


// VectorToBinary Returns binary of vector.
func VectorToBinary(arg0, arg1 Expr) Expr {
	return FunctionCall("vector_to_binary", arg0, arg1)
}


// Week Extracts the week of the year from a timestamp.
func Week(arg0 Expr) Expr {
	return FunctionCall("week", arg0)
}


// WeekOfYear Extracts the week of the year from a timestamp.
func WeekOfYear(expr Expr) Expr {
	return FunctionCall("week_of_year", expr)
}


// WeibullCdf Compute the Weibull cdf with given parameters a, b: P(N <= value). The a and b parameters must be positive doubles and value must also be a double.
func WeibullCdf(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("weibull_cdf", arg0, arg1, arg2)
}


// WidthBucket Returns the bucket number for a value in a histogram with uniform bucket widths.
func WidthBucket(operand, bound1, bound2, bucket_count Expr) Expr {
	return FunctionCall("width_bucket", operand, bound1, bound2, bucket_count)
}


// WilsonIntervalLower Returns the lower bound of the Wilson score interval of a Bernoulli trial process at a confidence specified by the z-score z.
func WilsonIntervalLower(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("wilson_interval_lower", arg0, arg1, arg2)
}


// WilsonIntervalUpper Returns the upper bound of the Wilson score interval of a Bernoulli trial process at a confidence specified by the z-score z.
func WilsonIntervalUpper(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("wilson_interval_upper", arg0, arg1, arg2)
}


// WordStem Returns the stem of a word using stemming algorithms.
func WordStem(string Expr) Expr {
	return FunctionCall("word_stem", string)
}


// Xxhash64 Computes a 64-bit XXHash of binary data.
func Xxhash64(arg0 Expr) Expr {
	return FunctionCall("xxhash64", arg0)
}


// Year Extracts the year from a timestamp.
func Year(expr Expr) Expr {
	return FunctionCall("year", expr)
}


// YearOfWeek Extracts the year of the ISO week from a date.
func YearOfWeek(arg0 Expr) Expr {
	return FunctionCall("year_of_week", arg0)
}


// Yow Extracts the year of the ISO week from a date.
func Yow(arg0 Expr) Expr {
	return FunctionCall("yow", arg0)
}


// ZiSplitPart Splits a string by delimiter and returns the part at the specified zero-based index.
func ZiSplitPart(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("zi_split_part", arg0, arg1, arg2)
}


// Zip Combines two lists element-wise into a list of paired structures.
func Zip(arg0, arg1 Expr) Expr {
	return FunctionCall("zip", arg0, arg1)
}


// ZipWith Combines two lists element-wise using a callback function to transform paired elements.
func ZipWith(arg0, arg1, arg2 Expr) Expr {
	return FunctionCall("zip_with", arg0, arg1, arg2)
}



// Mod calculates modulo
func Mod(a, b Expr) Expr {
	return FunctionCall("%", a, b)
}

// Cast converts a value to a target type
func Cast(expr Expr, to *arrowv1.ArrowType) Expr {
	return FunctionCall("cast", expr, &LiteralExpr{
		ScalarValue: &arrowv1.ScalarValue{
			Value: &arrowv1.ScalarValue_NullValue{
				NullValue: to,
			},
		},
		IsArrowScalarObject: true,
	})
}

// GetJsonValue extracts value from JSON
func GetJsonValue(json Expr, path string) Expr {
	return FunctionCall("get_json_value", json, String(path))
}

func stringsToArrowArrayBytes(values []string) (*arrowv1.ScalarListValue, error) {
	var builder array.Builder = array.NewLargeStringBuilder(memory.DefaultAllocator)
	stringBuilder := builder.(*array.LargeStringBuilder)
	defer builder.Release()
	for _, val := range values {
		stringBuilder.Append(val)
	}

	// Build the array
	arr := builder.NewArray()
	defer arr.Release()

	// Create a schema with a single field
	schema := arrow.NewSchema([]arrow.Field{
		{Name: "item", Type: arrow.BinaryTypes.LargeString, Nullable: true},
	}, nil)

	// Create a record with the array
	record := array.NewRecord(schema, []arrow.Array{arr}, int64(len(values)))
	defer record.Release()

	// Serialize to Arrow IPC format
	bws := &internal.BufferWriteSeeker{}
	writer, err := ipc.NewFileWriter(bws, ipc.WithSchema(schema), ipc.WithAllocator(memory.DefaultAllocator))
	if err != nil {
		return nil, fmt.Errorf("failed to create Arrow IPC writer: %w", err)
	}

	if err := writer.Write(record); err != nil {
		return nil, fmt.Errorf("failed to write Arrow record: %w", err)
	}

	if err := writer.Close(); err != nil {
		return nil, fmt.Errorf("failed to close Arrow writer: %w", err)
	}

	// Convert Arrow schema to protobuf Schema
	protoSchema, err := arrowSchemaToProto(schema)
	if err != nil {
		return nil, fmt.Errorf("failed to convert schema to proto: %w", err)
	}

	return &arrowv1.ScalarListValue{
		ArrowData: bws.Bytes(),
		Schema:    protoSchema,
	}, nil
}

type StructField struct {
	Name       string
	Expression Expr
}

// StructPack Create a struct value with the given columns.
func StructPack(fields []StructField) Expr {
	var keys []string
	var values []Expr
	for _, kv := range fields {
		keys = append(keys, kv.Name)
		values = append(values, kv.Expression)
	}
	keysArr, err := stringsToArrowArrayBytes(keys)
	if err != nil {
		panic(err)
	}
	keys_serialized := LiteralExpr{
		ScalarValue: &arrowv1.ScalarValue{
			Value: &arrowv1.ScalarValue_LargeListValue{
				LargeListValue: keysArr,
			},
		},
		// IMPORTANT -- we want this object to be interpreted NOT as an arrow value, but as a list of args that has
		// been serialized as an arrow scalar
		IsArrowScalarObject: false,
	}

	var final_values []Expr
	final_values = append(final_values, &keys_serialized)

	final_values = append(final_values, values...)
	return FunctionCall("struct_pack", final_values...)
}