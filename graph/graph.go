package graph

import (
	"fmt"

	"github.com/chalk-ai/chalk-go/expr"
	graphv1 "github.com/chalk-ai/chalk-go/gen/chalk/graph/v1"
	"github.com/iancoleman/strcase"
)

// shorthand useful for defining underscore expressions
func __(name string) expr.Expr {
	return expr.Identifier("_").Attr(name)
}

type Definitions struct {
	FeatureSets []*FeatureSet
}

func (d Definitions) WithFeatureSets(fs ...FeatureSet) Definitions {
	for _, f := range fs {
		d.FeatureSets = append(d.FeatureSets, &f)
	}
	return d
}

func (d Definitions) ToGraph() (*graphv1.Graph, error) {
	type protoWithExtras struct {
		proto       *graphv1.FeatureSet
		foreignKeys map[string]string
		primaryName string
		primaryType *ScalarFeatureBuilder
	}
	g := graphv1.Graph{}
	nameToFeatureSet := map[string]protoWithExtras{}
	for _, fs := range d.FeatureSets {
		// propagate errors (in the future, list all?)
		if fs.err != nil {
			return nil, fs.err
		}
		// TODO: infer primary if column named id is present
		if fs.primaryType == nil && !fs.IsSingleton {
			return nil, fmt.Errorf("feature set %s lacks primary column", fs.Name)
		}
		proto := fs.ToProto()

		g.FeatureSets = append(g.FeatureSets, proto)
		nameToFeatureSet[fs.namespace] = protoWithExtras{
			primaryName: fs.primaryName,
			primaryType: fs.primaryType,
			foreignKeys: fs.foreignKeys,
			proto:       proto,
		}
	}

	// resolve foreign references
	for _, fs := range g.FeatureSets {
		extras := nameToFeatureSet[fs.Name]
		// create join conditions for any has_many without them
		for _, f := range fs.Features {
			hm := f.GetHasMany()
			if hm != nil && hm.Join != nil {
				foreignExtras := nameToFeatureSet[hm.ForeignNamespace]
				foreignCol := expr.ColIn(foreignExtras.foreignKeys[fs.Name], hm.ForeignNamespace)
				primaryCol := expr.ColIn(extras.primaryName, fs.Name)
				hm.Join = expr.ToProto(foreignCol.Eq(primaryCol))
			}
		}
		// materialize foreign keys
		for featureSetName, foreignKeyName := range extras.foreignKeys {
			foreignExtras, exists := nameToFeatureSet[featureSetName]
			if !exists || foreignExtras.primaryType == nil {
				continue
			}
			extras.proto.Features = append(
				extras.proto.Features,
				foreignExtras.primaryType.ToProto(foreignKeyName, fs.Name),
			)
		}
	}

	return &g, nil
}

type FeatureSet struct {
	Name               string
	Features           []*graphv1.FeatureType
	IsSingleton        bool
	Tags               []string
	Owner              string
	Doc                string
	EtlOfflineToOnline bool

	// snakecase version of Name
	namespace string
	// whether errors were encountered during construction
	err error
	// map of feature set -> foreign key
	foreignKeys map[string]string
	// primary column
	primaryName string
	primaryType *ScalarFeatureBuilder
}

func (fs FeatureSet) With(name string, ofType FeatureBuilder) FeatureSet {
	if len(fs.namespace) == 0 {
		fs.namespace = strcase.ToSnake(fs.Name)
	}
	newFeatures, err := ofType.ToProtos(name, fs.namespace)
	if err != nil {
		fs.err = err
	} else {
		fs.Features = append(fs.Features, newFeatures...)
	}
	return fs
}

func (fs FeatureSet) WithPrimary(name string, ofType FeatureBuilder) FeatureSet {
	if fs.primaryType != nil {
		fs.err = fmt.Errorf("tried to add primary column %s, when %s already exists", name, fs.primaryName)
	}
	if len(fs.namespace) == 0 {
		fs.namespace = strcase.ToSnake(fs.Name)
	}
	scalarPtr, ok := ofType.(*ScalarFeatureBuilder)
	if !ok {
		fs.err = fmt.Errorf("primary column %s must be scalar (int or str)", name)
		return fs
	}
	scalar := *scalarPtr
	newFeatures, err := ofType.ToProtos(name, fs.namespace)
	if err != nil {
		fs.err = err
		return fs
	}
	newFeatures[0].Type.(*graphv1.FeatureType_Scalar).Scalar.IsPrimary = true
	fs.Features = append(fs.Features, newFeatures[0])
	fs.primaryName = name
	fs.primaryType = &scalar
	return fs
}

func (fs FeatureSet) WithForeignKey(name string, relation string) FeatureSet {
	if fs.foreignKeys == nil {
		fs.foreignKeys = make(map[string]string)
	}
	fs.foreignKeys[strcase.ToSnake(relation)] = name
	return fs
}

func MaybeStr(s string) *string {
	if s == "" {
		return nil
	}
	return &s
}

func (fs *FeatureSet) ToProto() *graphv1.FeatureSet {
	// TODO: add user-defined feature time
	featureTime := &graphv1.FeatureType{
		Type: &graphv1.FeatureType_FeatureTime{
			FeatureTime: &graphv1.FeatureTimeFeatureType{
				Name:            "__chalk_observed__",
				Namespace:       fs.namespace,
				IsAutogenerated: true,
				AttributeName:   "__chalk_observed__",
			},
		},
	}

	return &graphv1.FeatureSet{
		Name:        fs.namespace,
		Features:    append(fs.Features, featureTime),
		IsSingleton: fs.IsSingleton,
		Tags:        fs.Tags,
		Owner:       MaybeStr(fs.Owner),
		Doc:         MaybeStr(fs.Doc),
	}
}

type FeatureBuilder interface {
	ToProtos(string, string) ([]*graphv1.FeatureType, error)
}

type HasManyFeatureBuilder struct {
	ForeignNamespace string
}

func DataFrame(foreignName string) FeatureBuilder {
	return &HasManyFeatureBuilder{
		ForeignNamespace: strcase.ToSnake(foreignName),
	}
}

func (hm *HasManyFeatureBuilder) ToProtos(fieldName string, namespace string) ([]*graphv1.FeatureType, error) {
	return []*graphv1.FeatureType{
		{
			Type: &graphv1.FeatureType_HasMany{
				HasMany: &graphv1.HasManyFeatureType{
					ForeignNamespace:         hm.ForeignNamespace,
					Name:                     fieldName,
					Namespace:                namespace,
					AttributeName:            fieldName,
					UnversionedAttributeName: fieldName,
				},
			},
		},
	}, nil
}

type HasOneFeatureBuilder struct {
	proto *graphv1.HasOneFeatureType
}

type GroupByFeatureBuilder struct {
	proto *graphv1.GroupByFeatureType
}
