package graph

import (
	"fmt"

	"github.com/chalk-ai/chalk-go/expr"
	expressionv1 "github.com/chalk-ai/chalk-go/gen/chalk/expression/v1"
	graphv1 "github.com/chalk-ai/chalk-go/gen/chalk/graph/v1"
	"github.com/iancoleman/strcase"
)

// shorthand useful for defining underscore expressions
// NOTE: this isn't exported since it doesn't start with a capital letter
func __(name string) expr.Expr {
	return expr.Identifier("_").Attr(name)
}

type Definitions struct {
	FeatureSets []*FeatureSet
}

func (d Definitions) WithFeatureSets(fs ...FeatureSet) Definitions {
	for _, f := range fs {
		d.FeatureSets = append(d.FeatureSets, &f)
	}
	return d
}

func (d Definitions) ToGraph() (*graphv1.Graph, error) {
	type protoWithExtras struct {
		proto       *graphv1.FeatureSet
		foreignKeys map[string]string
		primaryName string
		primaryType *ScalarFeatureBuilder
	}
	g := graphv1.Graph{}
	nameToFeatureSet := map[string]protoWithExtras{}
	for _, fs := range d.FeatureSets {
		// propagate errors (in the future, list all?)
		if fs.err != nil {
			return nil, fs.err
		}
		// TODO: infer primary if column named id is present
		if fs.primaryType == nil && !fs.IsSingleton {
			return nil, fmt.Errorf("feature set %s lacks primary column", fs.Name)
		}
		proto := fs.ToProto()

		g.FeatureSets = append(g.FeatureSets, proto)
		nameToFeatureSet[fs.namespace] = protoWithExtras{
			primaryName: fs.primaryName,
			primaryType: fs.primaryType,
			foreignKeys: fs.foreignKeys,
			proto:       proto,
		}
	}

	// resolve foreign references
	for _, fs := range g.FeatureSets {
		extras := nameToFeatureSet[fs.Name]
		// create join conditions for any has_many without them
		for _, f := range fs.Features {
			hm := f.GetHasMany()
			if hm != nil && hm.Join == nil {
				foreignExtras := nameToFeatureSet[hm.ForeignNamespace]
				foreignCol := expr.ColIn(hm.ForeignNamespace, foreignExtras.foreignKeys[fs.Name])
				primaryCol := expr.ColIn(fs.Name, extras.primaryName)
				join, err := toFilterParsedProto(foreignCol.Eq(primaryCol))
				if err != nil {
					return nil, err
				}
				hm.Join = join
			}
		}
		// materialize foreign keys
		for featureSetName, foreignKeyName := range extras.foreignKeys {
			foreignExtras, exists := nameToFeatureSet[featureSetName]
			if !exists || foreignExtras.primaryType == nil {
				continue
			}
			extras.proto.Features = append(
				extras.proto.Features,
				foreignExtras.primaryType.ToProto(foreignKeyName, fs.Name),
			)
		}
	}

	return &g, nil
}

type FeatureSet struct {
	Name               string
	Features           []*graphv1.FeatureType
	IsSingleton        bool
	Tags               []string
	Owner              string
	Doc                string
	EtlOfflineToOnline bool

	// snakecase version of Name
	namespace string
	// whether errors were encountered during construction
	err error
	// map of feature set -> foreign key
	foreignKeys map[string]string
	// primary column
	primaryName string
	primaryType *ScalarFeatureBuilder
}

func (fs FeatureSet) With(name string, ofType FeatureBuilder) FeatureSet {
	if len(fs.namespace) == 0 {
		fs.namespace = strcase.ToSnake(fs.Name)
	}
	newFeatures, err := ofType.ToProtos(name, fs.namespace)
	if err != nil {
		fs.err = err
	} else {
		fs.Features = append(fs.Features, newFeatures...)
	}
	return fs
}

func (fs FeatureSet) WithPrimary(name string, ofType FeatureBuilder) FeatureSet {
	if fs.primaryType != nil {
		fs.err = fmt.Errorf("tried to add primary column %s, when %s already exists", name, fs.primaryName)
	}
	if len(fs.namespace) == 0 {
		fs.namespace = strcase.ToSnake(fs.Name)
	}
	scalarPtr, ok := ofType.(*ScalarFeatureBuilder)
	if !ok {
		fs.err = fmt.Errorf("primary column %s must be scalar (int or str)", name)
		return fs
	}
	scalar := *scalarPtr
	newFeatures, err := ofType.ToProtos(name, fs.namespace)
	if err != nil {
		fs.err = err
		return fs
	}
	newFeatures[0].Type.(*graphv1.FeatureType_Scalar).Scalar.IsPrimary = true
	fs.Features = append(fs.Features, newFeatures[0])
	fs.primaryName = name
	fs.primaryType = &scalar
	return fs
}

func (fs FeatureSet) WithForeignKey(name string, relation string) FeatureSet {
	if fs.foreignKeys == nil {
		fs.foreignKeys = make(map[string]string)
	}
	fs.foreignKeys[strcase.ToSnake(relation)] = name
	return fs
}

func MaybeStr(s string) *string {
	if s == "" {
		return nil
	}
	return &s
}

func (fs *FeatureSet) ToProto() *graphv1.FeatureSet {
	// TODO: add user-defined feature time
	featureTime := &graphv1.FeatureType{
		Type: &graphv1.FeatureType_FeatureTime{
			FeatureTime: &graphv1.FeatureTimeFeatureType{
				Name:            "__chalk_observed__",
				Namespace:       fs.namespace,
				IsAutogenerated: true,
				AttributeName:   "__chalk_observed__",
			},
		},
	}

	return &graphv1.FeatureSet{
		Name:        fs.namespace,
		Features:    append(fs.Features, featureTime),
		IsSingleton: fs.IsSingleton,
		Tags:        fs.Tags,
		Owner:       MaybeStr(fs.Owner),
		Doc:         MaybeStr(fs.Doc),
	}
}

type FeatureBuilder interface {
	ToProtos(string, string) ([]*graphv1.FeatureType, error)
}

type HasManyFeatureBuilder struct {
	ForeignNamespace string
}

func DataFrame(foreignName string) FeatureBuilder {
	return &HasManyFeatureBuilder{
		ForeignNamespace: strcase.ToSnake(foreignName),
	}
}

func (hm *HasManyFeatureBuilder) ToProtos(fieldName string, namespace string) ([]*graphv1.FeatureType, error) {
	return []*graphv1.FeatureType{
		{
			Type: &graphv1.FeatureType_HasMany{
				HasMany: &graphv1.HasManyFeatureType{
					ForeignNamespace:         hm.ForeignNamespace,
					Name:                     fieldName,
					Namespace:                namespace,
					AttributeName:            fieldName,
					UnversionedAttributeName: fieldName,
				},
			},
		},
	}, nil
}

// ToProto converts an ExprI to a LogicalExprNode proto message using legacy FilterParsed operators
func toFilterParsedProto(expression expr.ExprI) (*expressionv1.LogicalExprNode, error) {
	if expression == nil {
		return nil, nil
	}

	switch e := expression.(type) {
	case *expr.IdentifierExpr:
		return &expressionv1.LogicalExprNode{
			ExprType: &expressionv1.LogicalExprNode_Column{
				Column: &expressionv1.Column{
					Name: e.Name,
				},
			},
		}, nil

	case *expr.GetAttributeExpr:
		return &expressionv1.LogicalExprNode{
			ExprType: &expressionv1.LogicalExprNode_Column{
				Column: &expressionv1.Column{
					Name: e.Attribute,
				},
			},
		}, nil

	case *expr.LiteralExpr:
		return &expressionv1.LogicalExprNode{
			ExprType: &expressionv1.LogicalExprNode_Literal{
				Literal: e.ScalarValue,
			},
		}, nil

	case *expr.ColumnExpr:
		return &expressionv1.LogicalExprNode{
			ExprType: &expressionv1.LogicalExprNode_Column{
				Column: &expressionv1.Column{
					Name: e.Name,
					Relation: &expressionv1.ColumnRelation{
						Relation: e.Relation,
					},
				},
			},
		}, nil

	case *expr.CallExpr:
		op := e.Function.String()
		switch op {
		case "=":
			op = "=="
		case "AND":
			op = "and"
		case "OR":
			op = "or"
		case "NOT":
			op = "not"
		// these have the same symbol
		case "!=":
		case "<":
		case "<=":
		case ">":
		case ">=":
		// any others are not supported
		default:
			return nil, fmt.Errorf("operator %s not allowed in filters", op)
		}

		args := make([]*expressionv1.LogicalExprNode, len(e.Args))
		for i, e := range e.Args {
			proto, err := toFilterParsedProto(e)
			if err != nil {
				return nil, err
			}
			args[i] = proto
		}

		return &expressionv1.LogicalExprNode{
			ExprType: &expressionv1.LogicalExprNode_BinaryExpr{
				BinaryExpr: &expressionv1.BinaryExprNode{
					Op:       op,
					Operands: args,
				},
			},
		}, nil

	default:
		// Fallback for unknown expression types
		return nil, fmt.Errorf("invalid expression type for filter (%T)", e)
	}
}
