package graph

import (
	"fmt"
	"time"

	"github.com/chalk-ai/chalk-go/expr"
	arrowv1 "github.com/chalk-ai/chalk-go/gen/chalk/arrow/v1"
	graphv1 "github.com/chalk-ai/chalk-go/gen/chalk/graph/v1"
	proto "google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/durationpb"
)

type ScalarFeatureBuilder struct {
	proto *graphv1.ScalarFeatureType
	err   error
}

func (f ScalarFeatureBuilder) ToProto(fieldName string, namespace string) *graphv1.FeatureType {
	scalar := proto.Clone(f.proto).(*graphv1.ScalarFeatureType)
	scalar.Name = fieldName
	scalar.Namespace = namespace
	scalar.AttributeName = fieldName
	scalar.UnversionedAttributeName = fieldName
	return &graphv1.FeatureType{
		Type: &graphv1.FeatureType_Scalar{
			Scalar: scalar,
		},
	}
}

func featureTime(fieldName string, namespace string) *graphv1.FeatureType {
	return &graphv1.FeatureType{
		Type: &graphv1.FeatureType_FeatureTime{
			FeatureTime: &graphv1.FeatureTimeFeatureType{
				Name:            fieldName,
				Namespace:       namespace,
				IsAutogenerated: true,
				AttributeName:   fieldName,
			},
		},
	}
}

func (f ScalarFeatureBuilder) appendFeatures(features []*graphv1.FeatureType, fieldName string, namespace string) ([]*graphv1.FeatureType, error) {
	if f.err != nil {
		return nil, f.err
	}
	// handle special case of feature time
	if fieldName == "ts" {
		// check if ts is a datetime
		_, ok := f.proto.ArrowType.ArrowTypeEnum.(*arrowv1.ArrowType_Timestamp)
		if !ok {
			return nil, fmt.Errorf("ts field in %s must be a datetime", namespace)
		}
		return append(features, featureTime("ts", namespace)), nil
	} else {
		return append(features, f.ToProto(fieldName, namespace)), nil
	}
}

// WithMaxStaleness is equivalent to the max_staleness kwarg on feature in chalkpy
func (f ScalarFeatureBuilder) WithMaxStaleness(d time.Duration) ScalarFeatureBuilder {
	f.proto.MaxStalenessDuration = durationpb.New(d)
	return f
}

// Expr lets you define an underscore expression to compute a scalar feature
// For example
//
//	graph.FeatureSet{name: "Transaction"}.WithAll(graph.Features{"total": graph.Float, "sales_tax": graph.Float, "subtotal": graph.Float.Expr(expr.Col("total").Sub(expr.Col("sales_tax")))})
//
// is equivalent to the following chalkpy
//
//	@features
//	class Transaction:
//	  total: float
//	  sales_tax: float
//	  subtotal: float = _.total - _.sales_tax
func (ofType ScalarFeatureBuilder) Expr(expression expr.Expr) ScalarFeatureBuilder {
	scalar := proto.Clone(ofType.proto).(*graphv1.ScalarFeatureType)
	exproto, err := expr.ToProto(expression)
	if exproto != nil {
		scalar.Expression = exproto
	}
	return ScalarFeatureBuilder{
		proto: scalar,
		err:   err,
	}
}

// Optional modifies a scalar type to also specify None as a possible
// For example
//
//	graph.FeatureSet{name: "Transaction"}.With("memo": graph.Optional(graph.String))
//
// is equivalent to the following chalkpy
//
//	@features
//	class Transaction:
//	  memo: Optional[str]
func Optional(ofType *ScalarFeatureBuilder) *ScalarFeatureBuilder {
	scalar := proto.Clone(ofType.proto).(*graphv1.ScalarFeatureType)
	ofType.proto.IsNullable = true
	return &ScalarFeatureBuilder{
		proto: scalar,
		err:   ofType.err,
	}
}

// List lets you specify lists of a certain type
// For example
//
//	graph.FeatureSet{name: "User"}.With("recent_transaction_ids": graph.List(graph.Int))
//
// is equivalent to the following chalkpy
//
//	@features
//	class User:
//	  recent_transaction_ids: List[int]
func List(ofType *ScalarFeatureBuilder) *ScalarFeatureBuilder {
	scalar := proto.Clone(ofType.proto).(*graphv1.ScalarFeatureType)
	scalar.ArrowType = &arrowv1.ArrowType{
		ArrowTypeEnum: &arrowv1.ArrowType_LargeList{
			LargeList: &arrowv1.List{
				FieldType: &arrowv1.Field{
					Name:      "item",
					ArrowType: scalar.ArrowType,
					Nullable:  true,
				},
			},
		},
	}
	scalar.RichTypeInfo.RichTypeName = maybeStr(fmt.Sprintf("list[%s]", *scalar.RichTypeInfo.RichTypeName))
	return &ScalarFeatureBuilder{
		proto: scalar,
		err:   ofType.err,
	}
}

type FeatureTimeBuilder struct{}

func (f FeatureTimeBuilder) appendFeatures(features []*graphv1.FeatureType, fieldName string, namespace string) ([]*graphv1.FeatureType, error) {
	return append(features, featureTime(fieldName, namespace)), nil
}

// FeatureTime is equivalent to chalkpy FeatureTime
var FeatureTime = &FeatureTimeBuilder{}

func richType(name string) *graphv1.FeatureRichTypeInfo {
	module := "builtins"
	class := name
	if name == "datetime" {
		module = "datetime"
		class = "datetime.datetime"
	}
	return &graphv1.FeatureRichTypeInfo{
		RichTypeIsSameAsPrimitiveType: true,
		RichType: &graphv1.FeatureRichType{
			Type: &graphv1.FeatureRichType_ClassType{
				ClassType: &graphv1.RichClassType{
					ModuleName: module,
					Qualname:   name,
				},
			},
		},
		RichTypeName: maybeStr(fmt.Sprintf("<class '%s'>", class)),
	}
}

func arrowType(name string) *arrowv1.ArrowType {
	switch name {
	case "int":
		return &arrowv1.ArrowType{
			ArrowTypeEnum: &arrowv1.ArrowType_Int64{},
		}
	case "float":
		return &arrowv1.ArrowType{
			ArrowTypeEnum: &arrowv1.ArrowType_Float64{},
		}
	case "str":
		return &arrowv1.ArrowType{
			ArrowTypeEnum: &arrowv1.ArrowType_LargeUtf8{},
		}
	case "datetime":
		return &arrowv1.ArrowType{
			ArrowTypeEnum: &arrowv1.ArrowType_Timestamp{
				Timestamp: &arrowv1.Timestamp{
					TimeUnit: arrowv1.TimeUnit_TIME_UNIT_MICROSECOND,
					Timezone: "UTC",
				},
			},
		}
	case "bool":
		return &arrowv1.ArrowType{
			ArrowTypeEnum: &arrowv1.ArrowType_Bool{},
		}
	default:
		panic(fmt.Sprintf("invalid primitive name %s", name))
	}
}

var TRUE = true
var CENTURY = durationpb.Duration{Seconds: 3153600000}

func primitive(name string) *ScalarFeatureBuilder {
	return &ScalarFeatureBuilder{
		proto: &graphv1.ScalarFeatureType{
			ArrowType:          arrowType(name),
			CacheStrategy:      graphv1.CacheStrategy_CACHE_STRATEGY_ALL,
			StoreOnline:        &TRUE,
			StoreOffline:       &TRUE,
			RichTypeInfo:       richType(name),
			OfflineTtlDuration: &CENTURY,
		},
	}
}

// Int is equivalent to chalkpy int
var Int = primitive("int")

// Float is equivalent to chalkpy float
var Float = primitive("float")

// String is equivalent to chalkpy str
var String = primitive("str")

// Datetime is equivalent to chalkpy datetime.datetime
var Datetime = primitive("datetime")

// Boolean is equivalent to chalkpy bool
var Boolean = primitive("bool")

func TypeName(scalar *graphv1.ScalarFeatureType) string {
	return scalar.RichTypeInfo.RichType.Type.(*graphv1.FeatureRichType_ClassType).ClassType.Qualname
}

func arrowStruct(spec map[string]string) *arrowv1.ArrowType {
	fields := make([]*arrowv1.Field, len(spec))
	i := 0
	for name, typ := range spec {
		fields[i] = &arrowv1.Field{
			Name:      name,
			ArrowType: arrowType(typ),
			Nullable:  true,
		}
		i++
	}
	return &arrowv1.ArrowType{
		ArrowTypeEnum: &arrowv1.ArrowType_Struct{
			Struct: &arrowv1.Struct{
				SubFieldTypes: fields,
			},
		},
	}
}
