// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: chalk/kubernetes/v1/pods.proto

package kubernetesv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// PodStatusPubSub captures the state of a kubernetes pod.
type KubernetesPodData struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The Chalk team name that incurred the usage.
	Team            string `protobuf:"bytes,1,opt,name=team,proto3" json:"team,omitempty"`
	App             string `protobuf:"bytes,2,opt,name=app,proto3" json:"app,omitempty"`
	Component       string `protobuf:"bytes,3,opt,name=component,proto3" json:"component,omitempty"`
	DatadogService  string `protobuf:"bytes,4,opt,name=datadog_service,json=datadogService,proto3" json:"datadog_service,omitempty"`
	DatadogVersion  string `protobuf:"bytes,5,opt,name=datadog_version,json=datadogVersion,proto3" json:"datadog_version,omitempty"`
	PodTemplateHash string `protobuf:"bytes,6,opt,name=pod_template_hash,json=podTemplateHash,proto3" json:"pod_template_hash,omitempty"`
	// string status = 7;
	Status *KubernetesPodData_PodStatus `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
	Spec   *KubernetesPodData_PodSpec   `protobuf:"bytes,8,opt,name=spec,proto3" json:"spec,omitempty"`
	// The time that the instance was created.
	// pod.CreationTimestamp.Unix()
	CreationTimestamp int64 `protobuf:"varint,18,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"`
	// pod.DeletionTimestamp.Unix()
	// The time that the instance was deleted. May be 0 if the instance is still running.
	DeletionTimestamp int64 `protobuf:"varint,19,opt,name=deletion_timestamp,json=deletionTimestamp,proto3" json:"deletion_timestamp,omitempty"`
	// The time that we polled the instance for usage.
	ObservedTimestamp int64 `protobuf:"varint,20,opt,name=observed_timestamp,json=observedTimestamp,proto3" json:"observed_timestamp,omitempty"`
	// pod.Labels
	Labels map[string]string `protobuf:"bytes,21,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// pod.Annotations
	Annotations map[string]string `protobuf:"bytes,22,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Cluster     string            `protobuf:"bytes,23,opt,name=cluster,proto3" json:"cluster,omitempty"`
	// // node.UID
	Uid string `protobuf:"bytes,24,opt,name=uid,proto3" json:"uid,omitempty"`
	// // node.Name
	Name          string `protobuf:"bytes,25,opt,name=name,proto3" json:"name,omitempty"`
	Namespace     string `protobuf:"bytes,26,opt,name=namespace,proto3" json:"namespace,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData) Reset() {
	*x = KubernetesPodData{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData) ProtoMessage() {}

func (x *KubernetesPodData) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData.ProtoReflect.Descriptor instead.
func (*KubernetesPodData) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0}
}

func (x *KubernetesPodData) GetTeam() string {
	if x != nil {
		return x.Team
	}
	return ""
}

func (x *KubernetesPodData) GetApp() string {
	if x != nil {
		return x.App
	}
	return ""
}

func (x *KubernetesPodData) GetComponent() string {
	if x != nil {
		return x.Component
	}
	return ""
}

func (x *KubernetesPodData) GetDatadogService() string {
	if x != nil {
		return x.DatadogService
	}
	return ""
}

func (x *KubernetesPodData) GetDatadogVersion() string {
	if x != nil {
		return x.DatadogVersion
	}
	return ""
}

func (x *KubernetesPodData) GetPodTemplateHash() string {
	if x != nil {
		return x.PodTemplateHash
	}
	return ""
}

func (x *KubernetesPodData) GetStatus() *KubernetesPodData_PodStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *KubernetesPodData) GetSpec() *KubernetesPodData_PodSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *KubernetesPodData) GetCreationTimestamp() int64 {
	if x != nil {
		return x.CreationTimestamp
	}
	return 0
}

func (x *KubernetesPodData) GetDeletionTimestamp() int64 {
	if x != nil {
		return x.DeletionTimestamp
	}
	return 0
}

func (x *KubernetesPodData) GetObservedTimestamp() int64 {
	if x != nil {
		return x.ObservedTimestamp
	}
	return 0
}

func (x *KubernetesPodData) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *KubernetesPodData) GetAnnotations() map[string]string {
	if x != nil {
		return x.Annotations
	}
	return nil
}

func (x *KubernetesPodData) GetCluster() string {
	if x != nil {
		return x.Cluster
	}
	return ""
}

func (x *KubernetesPodData) GetUid() string {
	if x != nil {
		return x.Uid
	}
	return ""
}

func (x *KubernetesPodData) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *KubernetesPodData) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

// Volume represents a named volume in a pod that may be accessed by any container in the pod.
type KubernetesPodData_Volume struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name of the volume.
	// Must be a DNS_LABEL and unique within the pod.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_Volume) Reset() {
	*x = KubernetesPodData_Volume{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_Volume) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_Volume) ProtoMessage() {}

func (x *KubernetesPodData_Volume) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_Volume.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_Volume) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 0}
}

func (x *KubernetesPodData_Volume) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// ClaimSource describes a reference to a ResourceClaim.
//
// Exactly one of these fields should be set.  Consumers of this type must
// treat an empty object as if it has an unknown value.
type KubernetesPodData_ClaimSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ResourceClaimName is the name of a ResourceClaim object in the same
	// namespace as this pod.
	ResourceClaimName *string `protobuf:"bytes,1,opt,name=resource_claim_name,json=resourceClaimName,proto3,oneof" json:"resource_claim_name,omitempty"`
	// ResourceClaimTemplateName is the name of a ResourceClaimTemplate
	// object in the same namespace as this pod.
	//
	// The template will be used to create a new ResourceClaim, which will
	// be bound to this pod. When this pod is deleted, the ResourceClaim
	// will also be deleted. The pod name and resource name, along with a
	// generated component, will be used to form a unique name for the
	// ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
	//
	// This field is immutable and no changes will be made to the
	// corresponding ResourceClaim by the control plane after creating the
	// ResourceClaim.
	ResourceClaimTemplateName *string `protobuf:"bytes,2,opt,name=resource_claim_template_name,json=resourceClaimTemplateName,proto3,oneof" json:"resource_claim_template_name,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *KubernetesPodData_ClaimSource) Reset() {
	*x = KubernetesPodData_ClaimSource{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_ClaimSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_ClaimSource) ProtoMessage() {}

func (x *KubernetesPodData_ClaimSource) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_ClaimSource.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_ClaimSource) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 1}
}

func (x *KubernetesPodData_ClaimSource) GetResourceClaimName() string {
	if x != nil && x.ResourceClaimName != nil {
		return *x.ResourceClaimName
	}
	return ""
}

func (x *KubernetesPodData_ClaimSource) GetResourceClaimTemplateName() string {
	if x != nil && x.ResourceClaimTemplateName != nil {
		return *x.ResourceClaimTemplateName
	}
	return ""
}

// PodResourceClaim references exactly one ResourceClaim through a ClaimSource.
// It adds a name to it that uniquely identifies the ResourceClaim inside the Pod.
// Containers that need access to the ResourceClaim reference it with this name.
type KubernetesPodData_PodResourceClaim struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name uniquely identifies this resource claim inside the pod.
	// This must be a DNS_LABEL.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Source describes where to find the ResourceClaim.
	Source        *KubernetesPodData_ClaimSource `protobuf:"bytes,2,opt,name=source,proto3,oneof" json:"source,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_PodResourceClaim) Reset() {
	*x = KubernetesPodData_PodResourceClaim{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_PodResourceClaim) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_PodResourceClaim) ProtoMessage() {}

func (x *KubernetesPodData_PodResourceClaim) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_PodResourceClaim.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_PodResourceClaim) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 2}
}

func (x *KubernetesPodData_PodResourceClaim) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *KubernetesPodData_PodResourceClaim) GetSource() *KubernetesPodData_ClaimSource {
	if x != nil {
		return x.Source
	}
	return nil
}

// PodSpec is a description of a pod.
type KubernetesPodData_PodSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of volumes that can be mounted by containers belonging to the pod.
	// More info: https://kubernetes.io/docs/concepts/storage/volumes
	// +optional
	// +patchMergeKey=name
	// +patchStrategy=merge,retainKeys
	// +listType=map
	// +listMapKey=name
	Volumes []*KubernetesPodData_Volume `protobuf:"bytes,1,rep,name=volumes,proto3" json:"volumes,omitempty"`
	// List of initialization containers belonging to the pod.
	// Init containers are executed in order prior to containers being started. If any
	// init container fails, the pod is considered to have failed and is handled according
	// to its restartPolicy. The name for an init container or normal container must be
	// unique among all containers.
	// Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
	// The resourceRequirements of an init container are taken into account during scheduling
	// by finding the highest request/limit for each resource type, and then using the max of
	// of that value or the sum of the normal containers. Limits are applied to init containers
	// in a similar fashion.
	// Init containers cannot currently be added or removed.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
	// +patchMergeKey=name
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=name
	InitContainers []*KubernetesPodData_Container `protobuf:"bytes,20,rep,name=init_containers,json=initContainers,proto3" json:"init_containers,omitempty"`
	// List of containers belonging to the pod.
	// Containers cannot currently be added or removed.
	// There must be at least one container in a Pod.
	// Cannot be updated.
	// +patchMergeKey=name
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=name
	Containers []*KubernetesPodData_Container `protobuf:"bytes,2,rep,name=containers,proto3" json:"containers,omitempty"`
	// Restart policy for all containers within the pod.
	// One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
	// Default to Always.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
	// +optional
	RestartPolicy *string `protobuf:"bytes,3,opt,name=restart_policy,json=restartPolicy,proto3,oneof" json:"restart_policy,omitempty"`
	// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
	// Value must be non-negative integer. The value zero indicates stop immediately via
	// the kill signal (no opportunity to shut down).
	// If this value is nil, the default grace period will be used instead.
	// The grace period is the duration in seconds after the processes running in the pod are sent
	// a termination signal and the time when the processes are forcibly halted with a kill signal.
	// Set this value longer than the expected cleanup time for your process.
	// Defaults to 30 seconds.
	// +optional
	TerminationGracePeriodSeconds *int64 `protobuf:"varint,4,opt,name=termination_grace_period_seconds,json=terminationGracePeriodSeconds,proto3,oneof" json:"termination_grace_period_seconds,omitempty"`
	// Optional duration in seconds the pod may be active on the node relative to
	// start_time before the system will actively try to mark it failed and kill associated containers.
	// Value must be a positive integer.
	// +optional
	ActiveDeadlineSeconds *int64 `protobuf:"varint,5,opt,name=active_deadline_seconds,json=activeDeadlineSeconds,proto3,oneof" json:"active_deadline_seconds,omitempty"`
	// Set DNS policy for the pod.
	// Defaults to "ClusterFirst".
	// Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
	// DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
	// To have DNS options set along with hostNetwork, you have to specify DNS policy
	// explicitly to 'ClusterFirstWithHostNet'.
	// +optional
	DnsPolicy *string `protobuf:"bytes,6,opt,name=dns_policy,json=dnsPolicy,proto3,oneof" json:"dns_policy,omitempty"`
	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	// +optional
	// +mapType=atomic
	NodeSelector map[string]string `protobuf:"bytes,7,rep,name=node_selector,json=nodeSelector,proto3" json:"node_selector,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// ServiceAccountName is the name of the ServiceAccount to use to run this pod.
	// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
	// +optional
	ServiceAccountName *string `protobuf:"bytes,8,opt,name=service_account_name,json=serviceAccountName,proto3,oneof" json:"service_account_name,omitempty"`
	// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
	// +optional
	AutomountServiceAccountToken *bool `protobuf:"varint,21,opt,name=automount_service_account_token,json=automountServiceAccountToken,proto3,oneof" json:"automount_service_account_token,omitempty"`
	// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
	// the scheduler simply schedules this pod onto that node, assuming that it fits resource
	// requirements.
	// +optional
	NodeName *string `protobuf:"bytes,10,opt,name=node_name,json=nodeName,proto3,oneof" json:"node_name,omitempty"`
	// Host networking requested for this pod. Use the host's network namespace.
	// If this option is set, the ports that will be used must be specified.
	// Default to false.
	// +k8s:conversion-gen=false
	// +optional
	HostNetwork bool `protobuf:"varint,11,opt,name=host_network,json=hostNetwork,proto3" json:"host_network,omitempty"`
	// Use the host's pid namespace.
	// Optional: Default to false.
	// +k8s:conversion-gen=false
	// +optional
	HostPid bool `protobuf:"varint,12,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty"`
	// Use the host's ipc namespace.
	// Optional: Default to false.
	// +k8s:conversion-gen=false
	// +optional
	HostIpc bool `protobuf:"varint,13,opt,name=host_ipc,json=hostIpc,proto3" json:"host_ipc,omitempty"`
	// Share a single process namespace between all of the containers in a pod.
	// When this is set containers will be able to view and signal processes from other containers
	// in the same pod, and the first process in each container will not be assigned PID 1.
	// HostPID and ShareProcessNamespace cannot both be set.
	// Optional: Default to false.
	// +k8s:conversion-gen=false
	// +optional
	ShareProcessNamespace bool `protobuf:"varint,27,opt,name=share_process_namespace,json=shareProcessNamespace,proto3" json:"share_process_namespace,omitempty"`
	// Specifies the hostname of the Pod
	// If not specified, the pod's hostname will be set to a system-defined value.
	// +optional
	Hostname *string `protobuf:"bytes,16,opt,name=hostname,proto3,oneof" json:"hostname,omitempty"`
	// If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
	// If not specified, the pod will not have a domainname at all.
	// +optional
	Subdomain *string `protobuf:"bytes,17,opt,name=subdomain,proto3,oneof" json:"subdomain,omitempty"`
	// If specified, the pod will be dispatched by specified scheduler.
	// If not specified, the pod will be dispatched by default scheduler.
	// +optional
	SchedulerName *string `protobuf:"bytes,19,opt,name=scheduler_name,json=schedulerName,proto3,oneof" json:"scheduler_name,omitempty"`
	// If specified, indicates the pod's priority. "system-node-critical" and
	// "system-cluster-critical" are two special keywords which indicate the
	// highest priorities with the former being the highest priority. Any other
	// name must be defined by creating a PriorityClass object with that name.
	// If not specified, the pod priority will be default or zero if there is no
	// default.
	// +optional
	PriorityClassName *string `protobuf:"bytes,24,opt,name=priority_class_name,json=priorityClassName,proto3,oneof" json:"priority_class_name,omitempty"`
	// The priority value. Various system components use this field to find the
	// priority of the pod. When Priority Admission Controller is enabled, it
	// prevents users from setting this field. The admission controller populates
	// this field from priority_class_name.
	// The higher the value, the higher the priority.
	// +optional
	Priority *int32 `protobuf:"varint,25,opt,name=priority,proto3,oneof" json:"priority,omitempty"`
	// RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
	// to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
	// If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
	// empty definition that uses the default runtime handler.
	// More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
	// +optional
	RuntimeClassName *string `protobuf:"bytes,29,opt,name=runtime_class_name,json=runtimeClassName,proto3,oneof" json:"runtime_class_name,omitempty"`
	// EnableServiceLinks indicates whether information about services should be injected into pod's
	// environment variables, matching the syntax of Docker links.
	// Optional: Defaults to true.
	// +optional
	EnableServiceLinks *bool `protobuf:"varint,30,opt,name=enable_service_links,json=enableServiceLinks,proto3,oneof" json:"enable_service_links,omitempty"`
	// PreemptionPolicy is the Policy for preempting pods with lower priority.
	// One of Never, PreemptLowerPriority.
	// Defaults to PreemptLowerPriority if unset.
	// +optional
	PreemptionPolicy *string `protobuf:"bytes,31,opt,name=preemption_policy,json=preemptionPolicy,proto3,oneof" json:"preemption_policy,omitempty"`
	// Use the host's user namespace.
	// Optional: Default to true.
	// If set to true or not present, the pod will be run in the host user namespace, useful
	// for when the pod needs a feature only available to the host user namespace, such as
	// loading a kernel module with CAP_SYS_MODULE.
	// When set to false, a new userns is created for the pod. Setting false is useful for
	// mitigating container breakout vulnerabilities even allowing users to run their
	// containers as root without actually having root privileges on the host.
	// This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
	// +k8s:conversion-gen=false
	// +optional
	HostUsers *bool `protobuf:"varint,37,opt,name=host_users,json=hostUsers,proto3,oneof" json:"host_users,omitempty"`
	// ResourceClaims defines which ResourceClaims must be allocated
	// and reserved before the Pod is allowed to start. The resources
	// will be made available to those containers which consume them
	// by name.
	//
	// This is an alpha field and requires enabling the
	// DynamicResourceAllocation feature gate.
	//
	// This field is immutable.
	//
	// +patchMergeKey=name
	// +patchStrategy=merge,retainKeys
	// +listType=map
	// +listMapKey=name
	// +featureGate=DynamicResourceAllocation
	// +optional
	ResourceClaims []*KubernetesPodData_PodResourceClaim `protobuf:"bytes,39,rep,name=resource_claims,json=resourceClaims,proto3" json:"resource_claims,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *KubernetesPodData_PodSpec) Reset() {
	*x = KubernetesPodData_PodSpec{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_PodSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_PodSpec) ProtoMessage() {}

func (x *KubernetesPodData_PodSpec) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_PodSpec.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_PodSpec) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 3}
}

func (x *KubernetesPodData_PodSpec) GetVolumes() []*KubernetesPodData_Volume {
	if x != nil {
		return x.Volumes
	}
	return nil
}

func (x *KubernetesPodData_PodSpec) GetInitContainers() []*KubernetesPodData_Container {
	if x != nil {
		return x.InitContainers
	}
	return nil
}

func (x *KubernetesPodData_PodSpec) GetContainers() []*KubernetesPodData_Container {
	if x != nil {
		return x.Containers
	}
	return nil
}

func (x *KubernetesPodData_PodSpec) GetRestartPolicy() string {
	if x != nil && x.RestartPolicy != nil {
		return *x.RestartPolicy
	}
	return ""
}

func (x *KubernetesPodData_PodSpec) GetTerminationGracePeriodSeconds() int64 {
	if x != nil && x.TerminationGracePeriodSeconds != nil {
		return *x.TerminationGracePeriodSeconds
	}
	return 0
}

func (x *KubernetesPodData_PodSpec) GetActiveDeadlineSeconds() int64 {
	if x != nil && x.ActiveDeadlineSeconds != nil {
		return *x.ActiveDeadlineSeconds
	}
	return 0
}

func (x *KubernetesPodData_PodSpec) GetDnsPolicy() string {
	if x != nil && x.DnsPolicy != nil {
		return *x.DnsPolicy
	}
	return ""
}

func (x *KubernetesPodData_PodSpec) GetNodeSelector() map[string]string {
	if x != nil {
		return x.NodeSelector
	}
	return nil
}

func (x *KubernetesPodData_PodSpec) GetServiceAccountName() string {
	if x != nil && x.ServiceAccountName != nil {
		return *x.ServiceAccountName
	}
	return ""
}

func (x *KubernetesPodData_PodSpec) GetAutomountServiceAccountToken() bool {
	if x != nil && x.AutomountServiceAccountToken != nil {
		return *x.AutomountServiceAccountToken
	}
	return false
}

func (x *KubernetesPodData_PodSpec) GetNodeName() string {
	if x != nil && x.NodeName != nil {
		return *x.NodeName
	}
	return ""
}

func (x *KubernetesPodData_PodSpec) GetHostNetwork() bool {
	if x != nil {
		return x.HostNetwork
	}
	return false
}

func (x *KubernetesPodData_PodSpec) GetHostPid() bool {
	if x != nil {
		return x.HostPid
	}
	return false
}

func (x *KubernetesPodData_PodSpec) GetHostIpc() bool {
	if x != nil {
		return x.HostIpc
	}
	return false
}

func (x *KubernetesPodData_PodSpec) GetShareProcessNamespace() bool {
	if x != nil {
		return x.ShareProcessNamespace
	}
	return false
}

func (x *KubernetesPodData_PodSpec) GetHostname() string {
	if x != nil && x.Hostname != nil {
		return *x.Hostname
	}
	return ""
}

func (x *KubernetesPodData_PodSpec) GetSubdomain() string {
	if x != nil && x.Subdomain != nil {
		return *x.Subdomain
	}
	return ""
}

func (x *KubernetesPodData_PodSpec) GetSchedulerName() string {
	if x != nil && x.SchedulerName != nil {
		return *x.SchedulerName
	}
	return ""
}

func (x *KubernetesPodData_PodSpec) GetPriorityClassName() string {
	if x != nil && x.PriorityClassName != nil {
		return *x.PriorityClassName
	}
	return ""
}

func (x *KubernetesPodData_PodSpec) GetPriority() int32 {
	if x != nil && x.Priority != nil {
		return *x.Priority
	}
	return 0
}

func (x *KubernetesPodData_PodSpec) GetRuntimeClassName() string {
	if x != nil && x.RuntimeClassName != nil {
		return *x.RuntimeClassName
	}
	return ""
}

func (x *KubernetesPodData_PodSpec) GetEnableServiceLinks() bool {
	if x != nil && x.EnableServiceLinks != nil {
		return *x.EnableServiceLinks
	}
	return false
}

func (x *KubernetesPodData_PodSpec) GetPreemptionPolicy() string {
	if x != nil && x.PreemptionPolicy != nil {
		return *x.PreemptionPolicy
	}
	return ""
}

func (x *KubernetesPodData_PodSpec) GetHostUsers() bool {
	if x != nil && x.HostUsers != nil {
		return *x.HostUsers
	}
	return false
}

func (x *KubernetesPodData_PodSpec) GetResourceClaims() []*KubernetesPodData_PodResourceClaim {
	if x != nil {
		return x.ResourceClaims
	}
	return nil
}

// ContainerState holds a possible state of container.
// Only one of its members may be specified.
// If none of them is specified, the default one is ContainerStateWaiting.
type KubernetesPodData_ContainerState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Details about a waiting container
	// +optional
	Waiting *KubernetesPodData_ContainerStateWaiting `protobuf:"bytes,1,opt,name=waiting,proto3,oneof" json:"waiting,omitempty"`
	// Details about a running container
	// +optional
	Running *KubernetesPodData_ContainerStateRunning `protobuf:"bytes,2,opt,name=running,proto3,oneof" json:"running,omitempty"`
	// Details about a terminated container
	// +optional
	Terminated    *KubernetesPodData_ContainerStateTerminated `protobuf:"bytes,3,opt,name=terminated,proto3,oneof" json:"terminated,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_ContainerState) Reset() {
	*x = KubernetesPodData_ContainerState{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_ContainerState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_ContainerState) ProtoMessage() {}

func (x *KubernetesPodData_ContainerState) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_ContainerState.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_ContainerState) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 4}
}

func (x *KubernetesPodData_ContainerState) GetWaiting() *KubernetesPodData_ContainerStateWaiting {
	if x != nil {
		return x.Waiting
	}
	return nil
}

func (x *KubernetesPodData_ContainerState) GetRunning() *KubernetesPodData_ContainerStateRunning {
	if x != nil {
		return x.Running
	}
	return nil
}

func (x *KubernetesPodData_ContainerState) GetTerminated() *KubernetesPodData_ContainerStateTerminated {
	if x != nil {
		return x.Terminated
	}
	return nil
}

// ContainerStateRunning is a running state of a container.
type KubernetesPodData_ContainerStateRunning struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Time at which the container was last (re-)started
	// +optional
	StartedAt     int64 `protobuf:"varint,1,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_ContainerStateRunning) Reset() {
	*x = KubernetesPodData_ContainerStateRunning{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_ContainerStateRunning) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_ContainerStateRunning) ProtoMessage() {}

func (x *KubernetesPodData_ContainerStateRunning) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_ContainerStateRunning.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_ContainerStateRunning) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 5}
}

func (x *KubernetesPodData_ContainerStateRunning) GetStartedAt() int64 {
	if x != nil {
		return x.StartedAt
	}
	return 0
}

// ContainerStateTerminated is a terminated state of a container.
type KubernetesPodData_ContainerStateTerminated struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Exit status from the last termination of the container
	ExitCode int32 `protobuf:"varint,1,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	// Signal from the last termination of the container
	// +optional
	Signal *int32 `protobuf:"varint,2,opt,name=signal,proto3,oneof" json:"signal,omitempty"`
	// (brief) reason from the last termination of the container
	// +optional
	Reason *string `protobuf:"bytes,3,opt,name=reason,proto3,oneof" json:"reason,omitempty"`
	// Message regarding the last termination of the container
	// +optional
	Message *string `protobuf:"bytes,4,opt,name=message,proto3,oneof" json:"message,omitempty"`
	// Time at which previous execution of the container started
	// +optional
	StartedAt *int64 `protobuf:"varint,5,opt,name=started_at,json=startedAt,proto3,oneof" json:"started_at,omitempty"`
	// Time at which the container last terminated
	// +optional
	FinishedAt *int64 `protobuf:"varint,6,opt,name=finished_at,json=finishedAt,proto3,oneof" json:"finished_at,omitempty"`
	// Container's ID in the format '<type>://<container_id>'
	// +optional
	ContainerId   *string `protobuf:"bytes,7,opt,name=container_id,json=containerId,proto3,oneof" json:"container_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_ContainerStateTerminated) Reset() {
	*x = KubernetesPodData_ContainerStateTerminated{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_ContainerStateTerminated) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_ContainerStateTerminated) ProtoMessage() {}

func (x *KubernetesPodData_ContainerStateTerminated) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_ContainerStateTerminated.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_ContainerStateTerminated) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 6}
}

func (x *KubernetesPodData_ContainerStateTerminated) GetExitCode() int32 {
	if x != nil {
		return x.ExitCode
	}
	return 0
}

func (x *KubernetesPodData_ContainerStateTerminated) GetSignal() int32 {
	if x != nil && x.Signal != nil {
		return *x.Signal
	}
	return 0
}

func (x *KubernetesPodData_ContainerStateTerminated) GetReason() string {
	if x != nil && x.Reason != nil {
		return *x.Reason
	}
	return ""
}

func (x *KubernetesPodData_ContainerStateTerminated) GetMessage() string {
	if x != nil && x.Message != nil {
		return *x.Message
	}
	return ""
}

func (x *KubernetesPodData_ContainerStateTerminated) GetStartedAt() int64 {
	if x != nil && x.StartedAt != nil {
		return *x.StartedAt
	}
	return 0
}

func (x *KubernetesPodData_ContainerStateTerminated) GetFinishedAt() int64 {
	if x != nil && x.FinishedAt != nil {
		return *x.FinishedAt
	}
	return 0
}

func (x *KubernetesPodData_ContainerStateTerminated) GetContainerId() string {
	if x != nil && x.ContainerId != nil {
		return *x.ContainerId
	}
	return ""
}

// EnvVar represents an environment variable present in a Container.
type KubernetesPodData_EnvVar struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the environment variable. Must be a C_IDENTIFIER.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Variable references $(VAR_NAME) are expanded
	// using the previously defined environment variables in the container and
	// any service environment variables. If a variable cannot be resolved,
	// the reference in the input string will be unchanged. Double $$ are reduced
	// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
	// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
	// Escaped references will never be expanded, regardless of whether the variable
	// exists or not.
	// Defaults to "".
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Source for the environment variable's value. Cannot be used if value is not empty.
	// +optional
	ValueFrom     *KubernetesPodData_EnvVarSource `protobuf:"bytes,3,opt,name=value_from,json=valueFrom,proto3,oneof" json:"value_from,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_EnvVar) Reset() {
	*x = KubernetesPodData_EnvVar{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_EnvVar) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_EnvVar) ProtoMessage() {}

func (x *KubernetesPodData_EnvVar) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_EnvVar.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_EnvVar) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 7}
}

func (x *KubernetesPodData_EnvVar) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *KubernetesPodData_EnvVar) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *KubernetesPodData_EnvVar) GetValueFrom() *KubernetesPodData_EnvVarSource {
	if x != nil {
		return x.ValueFrom
	}
	return nil
}

// EnvVarSource represents a source for the value of an EnvVar.
type KubernetesPodData_EnvVarSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
	// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
	// +optional
	FieldRef *KubernetesPodData_ObjectFieldSelector `protobuf:"bytes,1,opt,name=field_ref,json=fieldRef,proto3,oneof" json:"field_ref,omitempty"`
	// Selects a resource of the container: only resources limits and requests
	// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
	// +optional
	ResourceFieldRef *KubernetesPodData_ResourceFieldSelector `protobuf:"bytes,2,opt,name=resource_field_ref,json=resourceFieldRef,proto3,oneof" json:"resource_field_ref,omitempty"`
	// Selects a key of a ConfigMap.
	// +optional
	ConfigMapKeyRef *KubernetesPodData_ConfigMapKeySelector `protobuf:"bytes,3,opt,name=config_map_key_ref,json=configMapKeyRef,proto3,oneof" json:"config_map_key_ref,omitempty"`
	// Selects a key of a secret in the pod's namespace
	// +optional
	SecretKeyRef  *KubernetesPodData_SecretKeySelector `protobuf:"bytes,4,opt,name=secret_key_ref,json=secretKeyRef,proto3,oneof" json:"secret_key_ref,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_EnvVarSource) Reset() {
	*x = KubernetesPodData_EnvVarSource{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_EnvVarSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_EnvVarSource) ProtoMessage() {}

func (x *KubernetesPodData_EnvVarSource) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_EnvVarSource.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_EnvVarSource) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 8}
}

func (x *KubernetesPodData_EnvVarSource) GetFieldRef() *KubernetesPodData_ObjectFieldSelector {
	if x != nil {
		return x.FieldRef
	}
	return nil
}

func (x *KubernetesPodData_EnvVarSource) GetResourceFieldRef() *KubernetesPodData_ResourceFieldSelector {
	if x != nil {
		return x.ResourceFieldRef
	}
	return nil
}

func (x *KubernetesPodData_EnvVarSource) GetConfigMapKeyRef() *KubernetesPodData_ConfigMapKeySelector {
	if x != nil {
		return x.ConfigMapKeyRef
	}
	return nil
}

func (x *KubernetesPodData_EnvVarSource) GetSecretKeyRef() *KubernetesPodData_SecretKeySelector {
	if x != nil {
		return x.SecretKeyRef
	}
	return nil
}

// ObjectFieldSelector selects an APIVersioned field of an object.
type KubernetesPodData_ObjectFieldSelector struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Version of the schema the FieldPath is written in terms of, defaults to "v1".
	// +optional
	ApiVersion string `protobuf:"bytes,1,opt,name=api_version,json=apiVersion,proto3" json:"api_version,omitempty"`
	// Path of the field to select in the specified API version.
	FieldPath     string `protobuf:"bytes,2,opt,name=field_path,json=fieldPath,proto3" json:"field_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_ObjectFieldSelector) Reset() {
	*x = KubernetesPodData_ObjectFieldSelector{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_ObjectFieldSelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_ObjectFieldSelector) ProtoMessage() {}

func (x *KubernetesPodData_ObjectFieldSelector) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_ObjectFieldSelector.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_ObjectFieldSelector) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 9}
}

func (x *KubernetesPodData_ObjectFieldSelector) GetApiVersion() string {
	if x != nil {
		return x.ApiVersion
	}
	return ""
}

func (x *KubernetesPodData_ObjectFieldSelector) GetFieldPath() string {
	if x != nil {
		return x.FieldPath
	}
	return ""
}

// ResourceFieldSelector represents container resources (cpu, memory) and their output format
type KubernetesPodData_ResourceFieldSelector struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Container name: required for volumes, optional for env vars
	// +optional
	ContainerName string `protobuf:"bytes,1,opt,name=container_name,json=containerName,proto3" json:"container_name,omitempty"`
	// Required: resource to select
	Resource string `protobuf:"bytes,2,opt,name=resource,proto3" json:"resource,omitempty"`
	// Specifies the output format of the exposed resources, defaults to "1"
	// +optional
	Divisor       *KubernetesPodData_Quantity `protobuf:"bytes,3,opt,name=divisor,proto3,oneof" json:"divisor,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_ResourceFieldSelector) Reset() {
	*x = KubernetesPodData_ResourceFieldSelector{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_ResourceFieldSelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_ResourceFieldSelector) ProtoMessage() {}

func (x *KubernetesPodData_ResourceFieldSelector) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_ResourceFieldSelector.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_ResourceFieldSelector) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 10}
}

func (x *KubernetesPodData_ResourceFieldSelector) GetContainerName() string {
	if x != nil {
		return x.ContainerName
	}
	return ""
}

func (x *KubernetesPodData_ResourceFieldSelector) GetResource() string {
	if x != nil {
		return x.Resource
	}
	return ""
}

func (x *KubernetesPodData_ResourceFieldSelector) GetDivisor() *KubernetesPodData_Quantity {
	if x != nil {
		return x.Divisor
	}
	return nil
}

// Selects a key from a ConfigMap.
type KubernetesPodData_ConfigMapKeySelector struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ConfigMap to select from.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The key to select.
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// Specify whether the ConfigMap or its key must be defined
	// +optional
	Optional      *bool `protobuf:"varint,3,opt,name=optional,proto3,oneof" json:"optional,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_ConfigMapKeySelector) Reset() {
	*x = KubernetesPodData_ConfigMapKeySelector{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_ConfigMapKeySelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_ConfigMapKeySelector) ProtoMessage() {}

func (x *KubernetesPodData_ConfigMapKeySelector) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_ConfigMapKeySelector.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_ConfigMapKeySelector) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 11}
}

func (x *KubernetesPodData_ConfigMapKeySelector) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *KubernetesPodData_ConfigMapKeySelector) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *KubernetesPodData_ConfigMapKeySelector) GetOptional() bool {
	if x != nil && x.Optional != nil {
		return *x.Optional
	}
	return false
}

// SecretKeySelector selects a key of a Secret.
type KubernetesPodData_SecretKeySelector struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the secret in the pod's namespace to select from.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The key of the secret to select from.  Must be a valid secret key.
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// Specify whether the Secret or its key must be defined
	// +optional
	Optional      *bool `protobuf:"varint,3,opt,name=optional,proto3,oneof" json:"optional,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_SecretKeySelector) Reset() {
	*x = KubernetesPodData_SecretKeySelector{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_SecretKeySelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_SecretKeySelector) ProtoMessage() {}

func (x *KubernetesPodData_SecretKeySelector) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_SecretKeySelector.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_SecretKeySelector) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 12}
}

func (x *KubernetesPodData_SecretKeySelector) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *KubernetesPodData_SecretKeySelector) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *KubernetesPodData_SecretKeySelector) GetOptional() bool {
	if x != nil && x.Optional != nil {
		return *x.Optional
	}
	return false
}

// EnvFromSource represents the source of a set of ConfigMaps
type KubernetesPodData_EnvFromSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
	// +optional
	Prefix *string `protobuf:"bytes,1,opt,name=prefix,proto3,oneof" json:"prefix,omitempty"`
	// The ConfigMap to select from
	// +optional
	ConfigMapRef *KubernetesPodData_ConfigMapEnvSource `protobuf:"bytes,2,opt,name=config_map_ref,json=configMapRef,proto3,oneof" json:"config_map_ref,omitempty"`
	// The Secret to select from
	// +optional
	SecretRef     *KubernetesPodData_SecretEnvSource `protobuf:"bytes,3,opt,name=secret_ref,json=secretRef,proto3,oneof" json:"secret_ref,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_EnvFromSource) Reset() {
	*x = KubernetesPodData_EnvFromSource{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_EnvFromSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_EnvFromSource) ProtoMessage() {}

func (x *KubernetesPodData_EnvFromSource) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_EnvFromSource.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_EnvFromSource) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 13}
}

func (x *KubernetesPodData_EnvFromSource) GetPrefix() string {
	if x != nil && x.Prefix != nil {
		return *x.Prefix
	}
	return ""
}

func (x *KubernetesPodData_EnvFromSource) GetConfigMapRef() *KubernetesPodData_ConfigMapEnvSource {
	if x != nil {
		return x.ConfigMapRef
	}
	return nil
}

func (x *KubernetesPodData_EnvFromSource) GetSecretRef() *KubernetesPodData_SecretEnvSource {
	if x != nil {
		return x.SecretRef
	}
	return nil
}

// ConfigMapEnvSource selects a ConfigMap to populate the environment
// variables with.
type KubernetesPodData_ConfigMapEnvSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ConfigMap to select from.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Specify whether the ConfigMap must be defined
	// +optional
	Optional      *bool `protobuf:"varint,2,opt,name=optional,proto3,oneof" json:"optional,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_ConfigMapEnvSource) Reset() {
	*x = KubernetesPodData_ConfigMapEnvSource{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_ConfigMapEnvSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_ConfigMapEnvSource) ProtoMessage() {}

func (x *KubernetesPodData_ConfigMapEnvSource) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_ConfigMapEnvSource.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_ConfigMapEnvSource) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 14}
}

func (x *KubernetesPodData_ConfigMapEnvSource) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *KubernetesPodData_ConfigMapEnvSource) GetOptional() bool {
	if x != nil && x.Optional != nil {
		return *x.Optional
	}
	return false
}

// SecretEnvSource selects a Secret to populate the environment
// variables with.
type KubernetesPodData_SecretEnvSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The Secret to select from.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Specify whether the Secret must be defined
	// +optional
	Optional      *bool `protobuf:"varint,2,opt,name=optional,proto3,oneof" json:"optional,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_SecretEnvSource) Reset() {
	*x = KubernetesPodData_SecretEnvSource{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_SecretEnvSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_SecretEnvSource) ProtoMessage() {}

func (x *KubernetesPodData_SecretEnvSource) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_SecretEnvSource.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_SecretEnvSource) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 15}
}

func (x *KubernetesPodData_SecretEnvSource) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *KubernetesPodData_SecretEnvSource) GetOptional() bool {
	if x != nil && x.Optional != nil {
		return *x.Optional
	}
	return false
}

// A single application container that you want to run within a pod.
type KubernetesPodData_Container struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the container specified as a DNS_LABEL.
	// Each container in a pod must have a unique name (DNS_LABEL).
	// Cannot be updated.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Container image name.
	// More info: https://kubernetes.io/docs/concepts/containers/images
	// This field is optional to allow higher level config management to default or override
	// container images in workload controllers like Deployments and StatefulSets.
	// +optional
	Image *string `protobuf:"bytes,2,opt,name=image,proto3,oneof" json:"image,omitempty"`
	// Entrypoint array. Not executed within a shell.
	// The container image's ENTRYPOINT is used if this is not provided.
	// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
	// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
	// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
	// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
	// of whether the variable exists or not. Cannot be updated.
	// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
	// +optional
	// +listType=atomic
	Command []string `protobuf:"bytes,3,rep,name=command,proto3" json:"command,omitempty"`
	// Arguments to the entrypoint.
	// The container image's CMD is used if this is not provided.
	// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
	// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
	// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
	// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
	// of whether the variable exists or not. Cannot be updated.
	// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
	// +optional
	// +listType=atomic
	Args []string `protobuf:"bytes,4,rep,name=args,proto3" json:"args,omitempty"`
	// Container's working directory.
	// If not specified, the container runtime's default will be used, which
	// might be configured in the container image.
	// Cannot be updated.
	// +optional
	WorkingDir *string `protobuf:"bytes,5,opt,name=working_dir,json=workingDir,proto3,oneof" json:"working_dir,omitempty"`
	// List of sources to populate environment variables in the container.
	// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
	// will be reported as an event when the container is starting. When a key exists in multiple
	// sources, the value associated with the last source will take precedence.
	// Values defined by an Env with a duplicate key will take precedence.
	// Cannot be updated.
	// +optional
	// +listType=atomic
	EnvFrom []*KubernetesPodData_EnvFromSource `protobuf:"bytes,19,rep,name=env_from,json=envFrom,proto3" json:"env_from,omitempty"`
	// List of environment variables to set in the container.
	// Cannot be updated.
	// +optional
	// +patchMergeKey=name
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=name
	Env []*KubernetesPodData_EnvVar `protobuf:"bytes,7,rep,name=env,proto3" json:"env,omitempty"`
	// Compute Resources required by this container.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	// +optional
	Resources *KubernetesPodData_ResourceRequirements `protobuf:"bytes,8,opt,name=resources,proto3,oneof" json:"resources,omitempty"`
	// RestartPolicy defines the restart behavior of individual containers in a pod.
	// This field may only be set for init containers, and the only allowed value is "Always".
	// For non-init containers or when this field is not specified,
	// the restart behavior is defined by the Pod's restart policy and the container type.
	// Setting the RestartPolicy as "Always" for the init container will have the following effect:
	// this init container will be continually restarted on
	// exit until all regular containers have terminated. Once all regular
	// containers have completed, all init containers with restartPolicy "Always"
	// will be shut down. This lifecycle differs from normal init containers and
	// is often referred to as a "sidecar" container. Although this init
	// container still starts in the init container sequence, it does not wait
	// for the container to complete before proceeding to the next init
	// container. Instead, the next init container starts immediately after this
	// init container is started, or after any startupProbe has successfully
	// completed.
	// +featureGate=SidecarContainers
	// +optional
	RestartPolicy *string `protobuf:"bytes,24,opt,name=restart_policy,json=restartPolicy,proto3,oneof" json:"restart_policy,omitempty"`
	// Optional: Path at which the file to which the container's termination message
	// will be written is mounted into the container's filesystem.
	// Message written is intended to be brief final status, such as an assertion failure message.
	// Will be truncated by the node if greater than 4096 bytes. The total message length across
	// all containers will be limited to 12kb.
	// Defaults to /dev/termination-log.
	// Cannot be updated.
	// +optional
	TerminationMessagePath *string `protobuf:"bytes,13,opt,name=termination_message_path,json=terminationMessagePath,proto3,oneof" json:"termination_message_path,omitempty"`
	// Indicate how the termination message should be populated. File will use the contents of
	// terminationMessagePath to populate the container status message on both success and failure.
	// FallbackToLogsOnError will use the last chunk of container log output if the termination
	// message file is empty and the container exited with an error.
	// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
	// Defaults to File.
	// Cannot be updated.
	// +optional
	TerminationMessagePolicy *string `protobuf:"bytes,20,opt,name=termination_message_policy,json=terminationMessagePolicy,proto3,oneof" json:"termination_message_policy,omitempty"`
	// Image pull policy.
	// One of Always, Never, IfNotPresent.
	// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
	// +optional
	ImagePullPolicy *string `protobuf:"bytes,14,opt,name=image_pull_policy,json=imagePullPolicy,proto3,oneof" json:"image_pull_policy,omitempty"`
	// Whether this container should allocate a buffer for stdin in the container runtime. If this
	// is not set, reads from stdin in the container will always result in EOF.
	Stdin bool `protobuf:"varint,16,opt,name=stdin,proto3" json:"stdin,omitempty"`
	// Whether the container runtime should close the stdin channel after it has been opened by
	// a single attach. When stdin is true the stdin stream will remain open across multiple attach
	// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
	// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
	// at which time stdin is closed and remains closed until the container is restarted. If this
	// flag is false, a container processes that reads from stdin will never receive an EOF.
	StdinOnce bool `protobuf:"varint,17,opt,name=stdin_once,json=stdinOnce,proto3" json:"stdin_once,omitempty"`
	// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
	Tty           bool `protobuf:"varint,18,opt,name=tty,proto3" json:"tty,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_Container) Reset() {
	*x = KubernetesPodData_Container{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_Container) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_Container) ProtoMessage() {}

func (x *KubernetesPodData_Container) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_Container.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_Container) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 16}
}

func (x *KubernetesPodData_Container) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *KubernetesPodData_Container) GetImage() string {
	if x != nil && x.Image != nil {
		return *x.Image
	}
	return ""
}

func (x *KubernetesPodData_Container) GetCommand() []string {
	if x != nil {
		return x.Command
	}
	return nil
}

func (x *KubernetesPodData_Container) GetArgs() []string {
	if x != nil {
		return x.Args
	}
	return nil
}

func (x *KubernetesPodData_Container) GetWorkingDir() string {
	if x != nil && x.WorkingDir != nil {
		return *x.WorkingDir
	}
	return ""
}

func (x *KubernetesPodData_Container) GetEnvFrom() []*KubernetesPodData_EnvFromSource {
	if x != nil {
		return x.EnvFrom
	}
	return nil
}

func (x *KubernetesPodData_Container) GetEnv() []*KubernetesPodData_EnvVar {
	if x != nil {
		return x.Env
	}
	return nil
}

func (x *KubernetesPodData_Container) GetResources() *KubernetesPodData_ResourceRequirements {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *KubernetesPodData_Container) GetRestartPolicy() string {
	if x != nil && x.RestartPolicy != nil {
		return *x.RestartPolicy
	}
	return ""
}

func (x *KubernetesPodData_Container) GetTerminationMessagePath() string {
	if x != nil && x.TerminationMessagePath != nil {
		return *x.TerminationMessagePath
	}
	return ""
}

func (x *KubernetesPodData_Container) GetTerminationMessagePolicy() string {
	if x != nil && x.TerminationMessagePolicy != nil {
		return *x.TerminationMessagePolicy
	}
	return ""
}

func (x *KubernetesPodData_Container) GetImagePullPolicy() string {
	if x != nil && x.ImagePullPolicy != nil {
		return *x.ImagePullPolicy
	}
	return ""
}

func (x *KubernetesPodData_Container) GetStdin() bool {
	if x != nil {
		return x.Stdin
	}
	return false
}

func (x *KubernetesPodData_Container) GetStdinOnce() bool {
	if x != nil {
		return x.StdinOnce
	}
	return false
}

func (x *KubernetesPodData_Container) GetTty() bool {
	if x != nil {
		return x.Tty
	}
	return false
}

// ContainerStateWaiting is a waiting state of a container.
type KubernetesPodData_ContainerStateWaiting struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// (brief) reason the container is not yet running.
	// +optional
	Reason *string `protobuf:"bytes,1,opt,name=reason,proto3,oneof" json:"reason,omitempty"`
	// Message regarding why the container is not yet running.
	// +optional
	Message       *string `protobuf:"bytes,2,opt,name=message,proto3,oneof" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_ContainerStateWaiting) Reset() {
	*x = KubernetesPodData_ContainerStateWaiting{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_ContainerStateWaiting) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_ContainerStateWaiting) ProtoMessage() {}

func (x *KubernetesPodData_ContainerStateWaiting) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_ContainerStateWaiting.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_ContainerStateWaiting) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 17}
}

func (x *KubernetesPodData_ContainerStateWaiting) GetReason() string {
	if x != nil && x.Reason != nil {
		return *x.Reason
	}
	return ""
}

func (x *KubernetesPodData_ContainerStateWaiting) GetMessage() string {
	if x != nil && x.Message != nil {
		return *x.Message
	}
	return ""
}

// ContainerStatus contains details for the current status of this container.
type KubernetesPodData_ContainerStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name is a DNS_LABEL representing the unique name of the container.
	// Each container in a pod must have a unique name across all container types.
	// Cannot be updated.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// State holds details about the container's current condition.
	// +optional
	State *KubernetesPodData_ContainerState `protobuf:"bytes,2,opt,name=state,proto3,oneof" json:"state,omitempty"`
	// LastTerminationState holds the last termination state of the container to
	// help debug container crashes and restarts. This field is not
	// populated if the container is still running and RestartCount is 0.
	// +optional
	LastState *KubernetesPodData_ContainerState `protobuf:"bytes,3,opt,name=last_state,json=lastState,proto3,oneof" json:"last_state,omitempty"`
	// Ready specifies whether the container is currently passing its readiness check.
	// The value will change as readiness probes keep executing. If no readiness
	// probes are specified, this field defaults to true once the container is
	// fully started (see Started field).
	//
	// The value is typically used to determine whether a container is ready to
	// accept traffic.
	Ready *bool `protobuf:"varint,4,opt,name=ready,proto3,oneof" json:"ready,omitempty"`
	// RestartCount holds the number of times the container has been restarted.
	// Kubelet makes an effort to always increment the value, but there
	// are cases when the state may be lost due to node restarts and then the value
	// may be reset to 0. The value is never negative.
	RestartCount int32 `protobuf:"varint,5,opt,name=restart_count,json=restartCount,proto3" json:"restart_count,omitempty"`
	// Image is the name of container image that the container is running.
	// The container image may not match the image used in the PodSpec,
	// as it may have been resolved by the runtime.
	// More info: https://kubernetes.io/docs/concepts/containers/images.
	Image string `protobuf:"bytes,6,opt,name=image,proto3" json:"image,omitempty"`
	// ImageID is the image ID of the container's image. The image ID may not
	// match the image ID of the image used in the PodSpec, as it may have been
	// resolved by the runtime.
	ImageId string `protobuf:"bytes,7,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
	// ContainerID is the ID of the container in the format '<type>://<container_id>'.
	// Where type is a container runtime identifier, returned from Version call of CRI API
	// (for example "containerd").
	// +optional
	ContainerId string `protobuf:"bytes,8,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	// Started indicates whether the container has finished its postStart lifecycle hook
	// and passed its startup probe.
	// Initialized as false, becomes true after startupProbe is considered
	// successful. Resets to false when the container is restarted, or if kubelet
	// loses state temporarily. In both cases, startup probes will run again.
	// Is always true when no startupProbe is defined and container is running and
	// has passed the postStart lifecycle hook.
	Started       bool `protobuf:"varint,9,opt,name=started,proto3" json:"started,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_ContainerStatus) Reset() {
	*x = KubernetesPodData_ContainerStatus{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_ContainerStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_ContainerStatus) ProtoMessage() {}

func (x *KubernetesPodData_ContainerStatus) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_ContainerStatus.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_ContainerStatus) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 18}
}

func (x *KubernetesPodData_ContainerStatus) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *KubernetesPodData_ContainerStatus) GetState() *KubernetesPodData_ContainerState {
	if x != nil {
		return x.State
	}
	return nil
}

func (x *KubernetesPodData_ContainerStatus) GetLastState() *KubernetesPodData_ContainerState {
	if x != nil {
		return x.LastState
	}
	return nil
}

func (x *KubernetesPodData_ContainerStatus) GetReady() bool {
	if x != nil && x.Ready != nil {
		return *x.Ready
	}
	return false
}

func (x *KubernetesPodData_ContainerStatus) GetRestartCount() int32 {
	if x != nil {
		return x.RestartCount
	}
	return 0
}

func (x *KubernetesPodData_ContainerStatus) GetImage() string {
	if x != nil {
		return x.Image
	}
	return ""
}

func (x *KubernetesPodData_ContainerStatus) GetImageId() string {
	if x != nil {
		return x.ImageId
	}
	return ""
}

func (x *KubernetesPodData_ContainerStatus) GetContainerId() string {
	if x != nil {
		return x.ContainerId
	}
	return ""
}

func (x *KubernetesPodData_ContainerStatus) GetStarted() bool {
	if x != nil {
		return x.Started
	}
	return false
}

type KubernetesPodData_Quantity struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	String_       *string                `protobuf:"bytes,1,opt,name=string,proto3,oneof" json:"string,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_Quantity) Reset() {
	*x = KubernetesPodData_Quantity{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_Quantity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_Quantity) ProtoMessage() {}

func (x *KubernetesPodData_Quantity) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_Quantity.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_Quantity) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 19}
}

func (x *KubernetesPodData_Quantity) GetString_() string {
	if x != nil && x.String_ != nil {
		return *x.String_
	}
	return ""
}

type KubernetesPodData_ResourceRequirements struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Limits describes the maximum amount of compute resources allowed.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	// +optional
	Limits map[string]*KubernetesPodData_Quantity `protobuf:"bytes,1,rep,name=limits,proto3" json:"limits,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Requests describes the minimum amount of compute resources required.
	// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
	// otherwise to an implementation-defined value. Requests cannot exceed Limits.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	// +optional
	Requests      map[string]*KubernetesPodData_Quantity `protobuf:"bytes,2,rep,name=requests,proto3" json:"requests,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_ResourceRequirements) Reset() {
	*x = KubernetesPodData_ResourceRequirements{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_ResourceRequirements) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_ResourceRequirements) ProtoMessage() {}

func (x *KubernetesPodData_ResourceRequirements) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_ResourceRequirements.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_ResourceRequirements) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 20}
}

func (x *KubernetesPodData_ResourceRequirements) GetLimits() map[string]*KubernetesPodData_Quantity {
	if x != nil {
		return x.Limits
	}
	return nil
}

func (x *KubernetesPodData_ResourceRequirements) GetRequests() map[string]*KubernetesPodData_Quantity {
	if x != nil {
		return x.Requests
	}
	return nil
}

// PodCondition contains details for the current condition of this pod.
type KubernetesPodData_PodCondition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Type is the type of the condition.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Status is the status of the condition.
	// Can be True, False, Unknown.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// Last time we probed the condition.
	// +optional
	LastProbeTime int64 `protobuf:"varint,3,opt,name=last_probe_time,json=lastProbeTime,proto3" json:"last_probe_time,omitempty"`
	// Last time the condition transitioned from one status to another.
	// +optional
	LastTransitionTime int64 `protobuf:"varint,4,opt,name=last_transition_time,json=lastTransitionTime,proto3" json:"last_transition_time,omitempty"`
	// Unique, one-word, CamelCase reason for the condition's last transition.
	// +optional
	Reason *string `protobuf:"bytes,5,opt,name=reason,proto3,oneof" json:"reason,omitempty"`
	// Human-readable message indicating details about last transition.
	// +optional
	Message       *string `protobuf:"bytes,6,opt,name=message,proto3,oneof" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_PodCondition) Reset() {
	*x = KubernetesPodData_PodCondition{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_PodCondition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_PodCondition) ProtoMessage() {}

func (x *KubernetesPodData_PodCondition) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_PodCondition.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_PodCondition) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 21}
}

func (x *KubernetesPodData_PodCondition) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *KubernetesPodData_PodCondition) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *KubernetesPodData_PodCondition) GetLastProbeTime() int64 {
	if x != nil {
		return x.LastProbeTime
	}
	return 0
}

func (x *KubernetesPodData_PodCondition) GetLastTransitionTime() int64 {
	if x != nil {
		return x.LastTransitionTime
	}
	return 0
}

func (x *KubernetesPodData_PodCondition) GetReason() string {
	if x != nil && x.Reason != nil {
		return *x.Reason
	}
	return ""
}

func (x *KubernetesPodData_PodCondition) GetMessage() string {
	if x != nil && x.Message != nil {
		return *x.Message
	}
	return ""
}

// HostIP represents a single IP address allocated to the host.
type KubernetesPodData_HostIP struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IP is the IP address assigned to the host
	Ip            *string `protobuf:"bytes,1,opt,name=ip,proto3,oneof" json:"ip,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_HostIP) Reset() {
	*x = KubernetesPodData_HostIP{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_HostIP) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_HostIP) ProtoMessage() {}

func (x *KubernetesPodData_HostIP) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_HostIP.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_HostIP) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 22}
}

func (x *KubernetesPodData_HostIP) GetIp() string {
	if x != nil && x.Ip != nil {
		return *x.Ip
	}
	return ""
}

// PodStatus represents information about the status of a pod. Status may trail the actual
// state of a system, especially if the node that hosts the pod cannot contact the control
// plane.
type KubernetesPodData_PodStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
	// The conditions array, the reason and message fields, and the individual container status
	// arrays contain more detail about the pod's status.
	// There are five possible phase values:
	//
	// Pending: The pod has been accepted by the Kubernetes system, but one or more of the
	// container images has not been created. This includes time before being scheduled as
	// well as time spent downloading images over the network, which could take a while.
	// Running: The pod has been bound to a node, and all of the containers have been created.
	// At least one container is still running, or is in the process of starting or restarting.
	// Succeeded: All containers in the pod have terminated in success, and will not be restarted.
	// Failed: All containers in the pod have terminated, and at least one container has
	// terminated in failure. The container either exited with non-zero status or was terminated
	// by the system.
	// Unknown: For some reason the state of the pod could not be obtained, typically due to an
	// error in communicating with the host of the pod.
	//
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
	// +optional
	Phase *string `protobuf:"bytes,1,opt,name=phase,proto3,oneof" json:"phase,omitempty"`
	// Current service state of pod.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	// +optional
	// +patchMergeKey=type
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=type
	Conditions []*KubernetesPodData_PodCondition `protobuf:"bytes,2,rep,name=conditions,proto3" json:"conditions,omitempty"`
	// A human readable message indicating details about why the pod is in this condition.
	// +optional
	Message *string `protobuf:"bytes,3,opt,name=message,proto3,oneof" json:"message,omitempty"`
	// A brief CamelCase message indicating details about why the pod is in this state.
	// e.g. 'Evicted'
	// +optional
	Reason *string `protobuf:"bytes,4,opt,name=reason,proto3,oneof" json:"reason,omitempty"`
	// nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
	// scheduled right away as preemption victims receive their graceful termination periods.
	// This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
	// to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
	// give the resources on this node to a higher priority pod that is created after preemption.
	// As a result, this field may be different than PodSpec.nodeName when the pod is
	// scheduled.
	// +optional
	NominatedNodeName *string `protobuf:"bytes,11,opt,name=nominated_node_name,json=nominatedNodeName,proto3,oneof" json:"nominated_node_name,omitempty"`
	// hostIP holds the IP address of the host to which the pod is assigned. Empty if the pod has not started yet.
	// A pod can be assigned to a node that has a problem in kubelet which in turns mean that HostIP will
	// not be updated even if there is a node is assigned to pod
	// +optional
	HostIp *string `protobuf:"bytes,5,opt,name=host_ip,json=hostIp,proto3,oneof" json:"host_ip,omitempty"`
	// hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
	// match the hostIP field. This list is empty if the pod has not started yet.
	// A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
	// not be updated even if there is a node is assigned to this pod.
	// +optional
	// +patchStrategy=merge
	// +patchMergeKey=ip
	// +listType=atomic
	HostIps []*KubernetesPodData_HostIP `protobuf:"bytes,16,rep,name=host_ips,json=hostIps,proto3" json:"host_ips,omitempty"`
	// podIP address allocated to the pod. Routable at least within the cluster.
	// Empty if not yet allocated.
	// +optional
	PodIp *string `protobuf:"bytes,6,opt,name=pod_ip,json=podIp,proto3,oneof" json:"pod_ip,omitempty"`
	// RFC 3339 date and time at which the object was acknowledged by the Kubelet.
	// This is before the Kubelet pulled the container image(s) for the pod.
	// +optional
	StartTime *int64 `protobuf:"varint,7,opt,name=start_time,json=startTime,proto3,oneof" json:"start_time,omitempty"`
	// The list has one entry per init container in the manifest. The most recent successful
	// init container will have ready = true, the most recently started container will have
	// startTime set.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
	// +listType=atomic
	InitContainerStatuses []*KubernetesPodData_ContainerStatus `protobuf:"bytes,10,rep,name=init_container_statuses,json=initContainerStatuses,proto3" json:"init_container_statuses,omitempty"`
	// The list has one entry per container in the manifest.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
	// +optional
	// +listType=atomic
	ContainerStatuses []*KubernetesPodData_ContainerStatus `protobuf:"bytes,8,rep,name=container_statuses,json=containerStatuses,proto3" json:"container_statuses,omitempty"`
	// The Quality of Service (QOS) classification assigned to the pod based on resource requirements
	// See PodQOSClass type for available QOS classes
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
	// +optional
	QosClass *string `protobuf:"bytes,9,opt,name=qos_class,json=qosClass,proto3,oneof" json:"qos_class,omitempty"`
	// Status for any ephemeral containers that have run in this pod.
	// +optional
	// +listType=atomic
	EphemeralContainerStatuses []*KubernetesPodData_ContainerStatus `protobuf:"bytes,13,rep,name=ephemeral_container_statuses,json=ephemeralContainerStatuses,proto3" json:"ephemeral_container_statuses,omitempty"`
	// Status of resources resize desired for pod's containers.
	// It is empty if no resources resize is pending.
	// Any changes to container resources will automatically set this to "Proposed"
	// +featureGate=InPlacePodVerticalScaling
	// +optional
	Resize        *string `protobuf:"bytes,14,opt,name=resize,proto3,oneof" json:"resize,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData_PodStatus) Reset() {
	*x = KubernetesPodData_PodStatus{}
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesPodData_PodStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesPodData_PodStatus) ProtoMessage() {}

func (x *KubernetesPodData_PodStatus) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_kubernetes_v1_pods_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesPodData_PodStatus.ProtoReflect.Descriptor instead.
func (*KubernetesPodData_PodStatus) Descriptor() ([]byte, []int) {
	return file_chalk_kubernetes_v1_pods_proto_rawDescGZIP(), []int{0, 23}
}

func (x *KubernetesPodData_PodStatus) GetPhase() string {
	if x != nil && x.Phase != nil {
		return *x.Phase
	}
	return ""
}

func (x *KubernetesPodData_PodStatus) GetConditions() []*KubernetesPodData_PodCondition {
	if x != nil {
		return x.Conditions
	}
	return nil
}

func (x *KubernetesPodData_PodStatus) GetMessage() string {
	if x != nil && x.Message != nil {
		return *x.Message
	}
	return ""
}

func (x *KubernetesPodData_PodStatus) GetReason() string {
	if x != nil && x.Reason != nil {
		return *x.Reason
	}
	return ""
}

func (x *KubernetesPodData_PodStatus) GetNominatedNodeName() string {
	if x != nil && x.NominatedNodeName != nil {
		return *x.NominatedNodeName
	}
	return ""
}

func (x *KubernetesPodData_PodStatus) GetHostIp() string {
	if x != nil && x.HostIp != nil {
		return *x.HostIp
	}
	return ""
}

func (x *KubernetesPodData_PodStatus) GetHostIps() []*KubernetesPodData_HostIP {
	if x != nil {
		return x.HostIps
	}
	return nil
}

func (x *KubernetesPodData_PodStatus) GetPodIp() string {
	if x != nil && x.PodIp != nil {
		return *x.PodIp
	}
	return ""
}

func (x *KubernetesPodData_PodStatus) GetStartTime() int64 {
	if x != nil && x.StartTime != nil {
		return *x.StartTime
	}
	return 0
}

func (x *KubernetesPodData_PodStatus) GetInitContainerStatuses() []*KubernetesPodData_ContainerStatus {
	if x != nil {
		return x.InitContainerStatuses
	}
	return nil
}

func (x *KubernetesPodData_PodStatus) GetContainerStatuses() []*KubernetesPodData_ContainerStatus {
	if x != nil {
		return x.ContainerStatuses
	}
	return nil
}

func (x *KubernetesPodData_PodStatus) GetQosClass() string {
	if x != nil && x.QosClass != nil {
		return *x.QosClass
	}
	return ""
}

func (x *KubernetesPodData_PodStatus) GetEphemeralContainerStatuses() []*KubernetesPodData_ContainerStatus {
	if x != nil {
		return x.EphemeralContainerStatuses
	}
	return nil
}

func (x *KubernetesPodData_PodStatus) GetResize() string {
	if x != nil && x.Resize != nil {
		return *x.Resize
	}
	return ""
}

var File_chalk_kubernetes_v1_pods_proto protoreflect.FileDescriptor

const file_chalk_kubernetes_v1_pods_proto_rawDesc = "" +
	"\n" +
	"\x1echalk/kubernetes/v1/pods.proto\x12\x13chalk.kubernetes.v1\"\xefA\n" +
	"\x11KubernetesPodData\x12\x12\n" +
	"\x04team\x18\x01 \x01(\tR\x04team\x12\x10\n" +
	"\x03app\x18\x02 \x01(\tR\x03app\x12\x1c\n" +
	"\tcomponent\x18\x03 \x01(\tR\tcomponent\x12'\n" +
	"\x0fdatadog_service\x18\x04 \x01(\tR\x0edatadogService\x12'\n" +
	"\x0fdatadog_version\x18\x05 \x01(\tR\x0edatadogVersion\x12*\n" +
	"\x11pod_template_hash\x18\x06 \x01(\tR\x0fpodTemplateHash\x12H\n" +
	"\x06status\x18\a \x01(\v20.chalk.kubernetes.v1.KubernetesPodData.PodStatusR\x06status\x12B\n" +
	"\x04spec\x18\b \x01(\v2..chalk.kubernetes.v1.KubernetesPodData.PodSpecR\x04spec\x12-\n" +
	"\x12creation_timestamp\x18\x12 \x01(\x03R\x11creationTimestamp\x12-\n" +
	"\x12deletion_timestamp\x18\x13 \x01(\x03R\x11deletionTimestamp\x12-\n" +
	"\x12observed_timestamp\x18\x14 \x01(\x03R\x11observedTimestamp\x12J\n" +
	"\x06labels\x18\x15 \x03(\v22.chalk.kubernetes.v1.KubernetesPodData.LabelsEntryR\x06labels\x12Y\n" +
	"\vannotations\x18\x16 \x03(\v27.chalk.kubernetes.v1.KubernetesPodData.AnnotationsEntryR\vannotations\x12\x18\n" +
	"\acluster\x18\x17 \x01(\tR\acluster\x12\x10\n" +
	"\x03uid\x18\x18 \x01(\tR\x03uid\x12\x12\n" +
	"\x04name\x18\x19 \x01(\tR\x04name\x12\x1c\n" +
	"\tnamespace\x18\x1a \x01(\tR\tnamespace\x1a\x1c\n" +
	"\x06Volume\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x1a\xc1\x01\n" +
	"\vClaimSource\x123\n" +
	"\x13resource_claim_name\x18\x01 \x01(\tH\x00R\x11resourceClaimName\x88\x01\x01\x12D\n" +
	"\x1cresource_claim_template_name\x18\x02 \x01(\tH\x01R\x19resourceClaimTemplateName\x88\x01\x01B\x16\n" +
	"\x14_resource_claim_nameB\x1f\n" +
	"\x1d_resource_claim_template_name\x1a\x82\x01\n" +
	"\x10PodResourceClaim\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12O\n" +
	"\x06source\x18\x02 \x01(\v22.chalk.kubernetes.v1.KubernetesPodData.ClaimSourceH\x00R\x06source\x88\x01\x01B\t\n" +
	"\a_source\x1a\xf6\r\n" +
	"\aPodSpec\x12G\n" +
	"\avolumes\x18\x01 \x03(\v2-.chalk.kubernetes.v1.KubernetesPodData.VolumeR\avolumes\x12Y\n" +
	"\x0finit_containers\x18\x14 \x03(\v20.chalk.kubernetes.v1.KubernetesPodData.ContainerR\x0einitContainers\x12P\n" +
	"\n" +
	"containers\x18\x02 \x03(\v20.chalk.kubernetes.v1.KubernetesPodData.ContainerR\n" +
	"containers\x12*\n" +
	"\x0erestart_policy\x18\x03 \x01(\tH\x00R\rrestartPolicy\x88\x01\x01\x12L\n" +
	" termination_grace_period_seconds\x18\x04 \x01(\x03H\x01R\x1dterminationGracePeriodSeconds\x88\x01\x01\x12;\n" +
	"\x17active_deadline_seconds\x18\x05 \x01(\x03H\x02R\x15activeDeadlineSeconds\x88\x01\x01\x12\"\n" +
	"\n" +
	"dns_policy\x18\x06 \x01(\tH\x03R\tdnsPolicy\x88\x01\x01\x12e\n" +
	"\rnode_selector\x18\a \x03(\v2@.chalk.kubernetes.v1.KubernetesPodData.PodSpec.NodeSelectorEntryR\fnodeSelector\x125\n" +
	"\x14service_account_name\x18\b \x01(\tH\x04R\x12serviceAccountName\x88\x01\x01\x12J\n" +
	"\x1fautomount_service_account_token\x18\x15 \x01(\bH\x05R\x1cautomountServiceAccountToken\x88\x01\x01\x12 \n" +
	"\tnode_name\x18\n" +
	" \x01(\tH\x06R\bnodeName\x88\x01\x01\x12!\n" +
	"\fhost_network\x18\v \x01(\bR\vhostNetwork\x12\x19\n" +
	"\bhost_pid\x18\f \x01(\bR\ahostPid\x12\x19\n" +
	"\bhost_ipc\x18\r \x01(\bR\ahostIpc\x126\n" +
	"\x17share_process_namespace\x18\x1b \x01(\bR\x15shareProcessNamespace\x12\x1f\n" +
	"\bhostname\x18\x10 \x01(\tH\aR\bhostname\x88\x01\x01\x12!\n" +
	"\tsubdomain\x18\x11 \x01(\tH\bR\tsubdomain\x88\x01\x01\x12*\n" +
	"\x0escheduler_name\x18\x13 \x01(\tH\tR\rschedulerName\x88\x01\x01\x123\n" +
	"\x13priority_class_name\x18\x18 \x01(\tH\n" +
	"R\x11priorityClassName\x88\x01\x01\x12\x1f\n" +
	"\bpriority\x18\x19 \x01(\x05H\vR\bpriority\x88\x01\x01\x121\n" +
	"\x12runtime_class_name\x18\x1d \x01(\tH\fR\x10runtimeClassName\x88\x01\x01\x125\n" +
	"\x14enable_service_links\x18\x1e \x01(\bH\rR\x12enableServiceLinks\x88\x01\x01\x120\n" +
	"\x11preemption_policy\x18\x1f \x01(\tH\x0eR\x10preemptionPolicy\x88\x01\x01\x12\"\n" +
	"\n" +
	"host_users\x18% \x01(\bH\x0fR\thostUsers\x88\x01\x01\x12`\n" +
	"\x0fresource_claims\x18' \x03(\v27.chalk.kubernetes.v1.KubernetesPodData.PodResourceClaimR\x0eresourceClaims\x1a?\n" +
	"\x11NodeSelectorEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\x11\n" +
	"\x0f_restart_policyB#\n" +
	"!_termination_grace_period_secondsB\x1a\n" +
	"\x18_active_deadline_secondsB\r\n" +
	"\v_dns_policyB\x17\n" +
	"\x15_service_account_nameB\"\n" +
	" _automount_service_account_tokenB\f\n" +
	"\n" +
	"_node_nameB\v\n" +
	"\t_hostnameB\f\n" +
	"\n" +
	"_subdomainB\x11\n" +
	"\x0f_scheduler_nameB\x16\n" +
	"\x14_priority_class_nameB\v\n" +
	"\t_priorityB\x15\n" +
	"\x13_runtime_class_nameB\x17\n" +
	"\x15_enable_service_linksB\x14\n" +
	"\x12_preemption_policyB\r\n" +
	"\v_host_users\x1a\xd7\x02\n" +
	"\x0eContainerState\x12[\n" +
	"\awaiting\x18\x01 \x01(\v2<.chalk.kubernetes.v1.KubernetesPodData.ContainerStateWaitingH\x00R\awaiting\x88\x01\x01\x12[\n" +
	"\arunning\x18\x02 \x01(\v2<.chalk.kubernetes.v1.KubernetesPodData.ContainerStateRunningH\x01R\arunning\x88\x01\x01\x12d\n" +
	"\n" +
	"terminated\x18\x03 \x01(\v2?.chalk.kubernetes.v1.KubernetesPodData.ContainerStateTerminatedH\x02R\n" +
	"terminated\x88\x01\x01B\n" +
	"\n" +
	"\b_waitingB\n" +
	"\n" +
	"\b_runningB\r\n" +
	"\v_terminated\x1a6\n" +
	"\x15ContainerStateRunning\x12\x1d\n" +
	"\n" +
	"started_at\x18\x01 \x01(\x03R\tstartedAt\x1a\xd4\x02\n" +
	"\x18ContainerStateTerminated\x12\x1b\n" +
	"\texit_code\x18\x01 \x01(\x05R\bexitCode\x12\x1b\n" +
	"\x06signal\x18\x02 \x01(\x05H\x00R\x06signal\x88\x01\x01\x12\x1b\n" +
	"\x06reason\x18\x03 \x01(\tH\x01R\x06reason\x88\x01\x01\x12\x1d\n" +
	"\amessage\x18\x04 \x01(\tH\x02R\amessage\x88\x01\x01\x12\"\n" +
	"\n" +
	"started_at\x18\x05 \x01(\x03H\x03R\tstartedAt\x88\x01\x01\x12$\n" +
	"\vfinished_at\x18\x06 \x01(\x03H\x04R\n" +
	"finishedAt\x88\x01\x01\x12&\n" +
	"\fcontainer_id\x18\a \x01(\tH\x05R\vcontainerId\x88\x01\x01B\t\n" +
	"\a_signalB\t\n" +
	"\a_reasonB\n" +
	"\n" +
	"\b_messageB\r\n" +
	"\v_started_atB\x0e\n" +
	"\f_finished_atB\x0f\n" +
	"\r_container_id\x1a\x9a\x01\n" +
	"\x06EnvVar\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\x12W\n" +
	"\n" +
	"value_from\x18\x03 \x01(\v23.chalk.kubernetes.v1.KubernetesPodData.EnvVarSourceH\x00R\tvalueFrom\x88\x01\x01B\r\n" +
	"\v_value_from\x1a\x80\x04\n" +
	"\fEnvVarSource\x12\\\n" +
	"\tfield_ref\x18\x01 \x01(\v2:.chalk.kubernetes.v1.KubernetesPodData.ObjectFieldSelectorH\x00R\bfieldRef\x88\x01\x01\x12o\n" +
	"\x12resource_field_ref\x18\x02 \x01(\v2<.chalk.kubernetes.v1.KubernetesPodData.ResourceFieldSelectorH\x01R\x10resourceFieldRef\x88\x01\x01\x12m\n" +
	"\x12config_map_key_ref\x18\x03 \x01(\v2;.chalk.kubernetes.v1.KubernetesPodData.ConfigMapKeySelectorH\x02R\x0fconfigMapKeyRef\x88\x01\x01\x12c\n" +
	"\x0esecret_key_ref\x18\x04 \x01(\v28.chalk.kubernetes.v1.KubernetesPodData.SecretKeySelectorH\x03R\fsecretKeyRef\x88\x01\x01B\f\n" +
	"\n" +
	"_field_refB\x15\n" +
	"\x13_resource_field_refB\x15\n" +
	"\x13_config_map_key_refB\x11\n" +
	"\x0f_secret_key_ref\x1aU\n" +
	"\x13ObjectFieldSelector\x12\x1f\n" +
	"\vapi_version\x18\x01 \x01(\tR\n" +
	"apiVersion\x12\x1d\n" +
	"\n" +
	"field_path\x18\x02 \x01(\tR\tfieldPath\x1a\xb6\x01\n" +
	"\x15ResourceFieldSelector\x12%\n" +
	"\x0econtainer_name\x18\x01 \x01(\tR\rcontainerName\x12\x1a\n" +
	"\bresource\x18\x02 \x01(\tR\bresource\x12N\n" +
	"\adivisor\x18\x03 \x01(\v2/.chalk.kubernetes.v1.KubernetesPodData.QuantityH\x00R\adivisor\x88\x01\x01B\n" +
	"\n" +
	"\b_divisor\x1aj\n" +
	"\x14ConfigMapKeySelector\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x10\n" +
	"\x03key\x18\x02 \x01(\tR\x03key\x12\x1f\n" +
	"\boptional\x18\x03 \x01(\bH\x00R\boptional\x88\x01\x01B\v\n" +
	"\t_optional\x1ag\n" +
	"\x11SecretKeySelector\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x10\n" +
	"\x03key\x18\x02 \x01(\tR\x03key\x12\x1f\n" +
	"\boptional\x18\x03 \x01(\bH\x00R\boptional\x88\x01\x01B\v\n" +
	"\t_optional\x1a\x9b\x02\n" +
	"\rEnvFromSource\x12\x1b\n" +
	"\x06prefix\x18\x01 \x01(\tH\x00R\x06prefix\x88\x01\x01\x12d\n" +
	"\x0econfig_map_ref\x18\x02 \x01(\v29.chalk.kubernetes.v1.KubernetesPodData.ConfigMapEnvSourceH\x01R\fconfigMapRef\x88\x01\x01\x12Z\n" +
	"\n" +
	"secret_ref\x18\x03 \x01(\v26.chalk.kubernetes.v1.KubernetesPodData.SecretEnvSourceH\x02R\tsecretRef\x88\x01\x01B\t\n" +
	"\a_prefixB\x11\n" +
	"\x0f_config_map_refB\r\n" +
	"\v_secret_ref\x1aV\n" +
	"\x12ConfigMapEnvSource\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1f\n" +
	"\boptional\x18\x02 \x01(\bH\x00R\boptional\x88\x01\x01B\v\n" +
	"\t_optional\x1aS\n" +
	"\x0fSecretEnvSource\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1f\n" +
	"\boptional\x18\x02 \x01(\bH\x00R\boptional\x88\x01\x01B\v\n" +
	"\t_optional\x1a\xb3\x06\n" +
	"\tContainer\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x19\n" +
	"\x05image\x18\x02 \x01(\tH\x00R\x05image\x88\x01\x01\x12\x18\n" +
	"\acommand\x18\x03 \x03(\tR\acommand\x12\x12\n" +
	"\x04args\x18\x04 \x03(\tR\x04args\x12$\n" +
	"\vworking_dir\x18\x05 \x01(\tH\x01R\n" +
	"workingDir\x88\x01\x01\x12O\n" +
	"\benv_from\x18\x13 \x03(\v24.chalk.kubernetes.v1.KubernetesPodData.EnvFromSourceR\aenvFrom\x12?\n" +
	"\x03env\x18\a \x03(\v2-.chalk.kubernetes.v1.KubernetesPodData.EnvVarR\x03env\x12^\n" +
	"\tresources\x18\b \x01(\v2;.chalk.kubernetes.v1.KubernetesPodData.ResourceRequirementsH\x02R\tresources\x88\x01\x01\x12*\n" +
	"\x0erestart_policy\x18\x18 \x01(\tH\x03R\rrestartPolicy\x88\x01\x01\x12=\n" +
	"\x18termination_message_path\x18\r \x01(\tH\x04R\x16terminationMessagePath\x88\x01\x01\x12A\n" +
	"\x1atermination_message_policy\x18\x14 \x01(\tH\x05R\x18terminationMessagePolicy\x88\x01\x01\x12/\n" +
	"\x11image_pull_policy\x18\x0e \x01(\tH\x06R\x0fimagePullPolicy\x88\x01\x01\x12\x14\n" +
	"\x05stdin\x18\x10 \x01(\bR\x05stdin\x12\x1d\n" +
	"\n" +
	"stdin_once\x18\x11 \x01(\bR\tstdinOnce\x12\x10\n" +
	"\x03tty\x18\x12 \x01(\bR\x03ttyB\b\n" +
	"\x06_imageB\x0e\n" +
	"\f_working_dirB\f\n" +
	"\n" +
	"_resourcesB\x11\n" +
	"\x0f_restart_policyB\x1b\n" +
	"\x19_termination_message_pathB\x1d\n" +
	"\x1b_termination_message_policyB\x14\n" +
	"\x12_image_pull_policy\x1aj\n" +
	"\x15ContainerStateWaiting\x12\x1b\n" +
	"\x06reason\x18\x01 \x01(\tH\x00R\x06reason\x88\x01\x01\x12\x1d\n" +
	"\amessage\x18\x02 \x01(\tH\x01R\amessage\x88\x01\x01B\t\n" +
	"\a_reasonB\n" +
	"\n" +
	"\b_message\x1a\xa3\x03\n" +
	"\x0fContainerStatus\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12P\n" +
	"\x05state\x18\x02 \x01(\v25.chalk.kubernetes.v1.KubernetesPodData.ContainerStateH\x00R\x05state\x88\x01\x01\x12Y\n" +
	"\n" +
	"last_state\x18\x03 \x01(\v25.chalk.kubernetes.v1.KubernetesPodData.ContainerStateH\x01R\tlastState\x88\x01\x01\x12\x19\n" +
	"\x05ready\x18\x04 \x01(\bH\x02R\x05ready\x88\x01\x01\x12#\n" +
	"\rrestart_count\x18\x05 \x01(\x05R\frestartCount\x12\x14\n" +
	"\x05image\x18\x06 \x01(\tR\x05image\x12\x19\n" +
	"\bimage_id\x18\a \x01(\tR\aimageId\x12!\n" +
	"\fcontainer_id\x18\b \x01(\tR\vcontainerId\x12\x18\n" +
	"\astarted\x18\t \x01(\bR\astartedB\b\n" +
	"\x06_stateB\r\n" +
	"\v_last_stateB\b\n" +
	"\x06_ready\x1a2\n" +
	"\bQuantity\x12\x1b\n" +
	"\x06string\x18\x01 \x01(\tH\x00R\x06string\x88\x01\x01B\t\n" +
	"\a_string\x1a\xb8\x03\n" +
	"\x14ResourceRequirements\x12_\n" +
	"\x06limits\x18\x01 \x03(\v2G.chalk.kubernetes.v1.KubernetesPodData.ResourceRequirements.LimitsEntryR\x06limits\x12e\n" +
	"\brequests\x18\x02 \x03(\v2I.chalk.kubernetes.v1.KubernetesPodData.ResourceRequirements.RequestsEntryR\brequests\x1aj\n" +
	"\vLimitsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12E\n" +
	"\x05value\x18\x02 \x01(\v2/.chalk.kubernetes.v1.KubernetesPodData.QuantityR\x05value:\x028\x01\x1al\n" +
	"\rRequestsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12E\n" +
	"\x05value\x18\x02 \x01(\v2/.chalk.kubernetes.v1.KubernetesPodData.QuantityR\x05value:\x028\x01\x1a\xe7\x01\n" +
	"\fPodCondition\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\x16\n" +
	"\x06status\x18\x02 \x01(\tR\x06status\x12&\n" +
	"\x0flast_probe_time\x18\x03 \x01(\x03R\rlastProbeTime\x120\n" +
	"\x14last_transition_time\x18\x04 \x01(\x03R\x12lastTransitionTime\x12\x1b\n" +
	"\x06reason\x18\x05 \x01(\tH\x00R\x06reason\x88\x01\x01\x12\x1d\n" +
	"\amessage\x18\x06 \x01(\tH\x01R\amessage\x88\x01\x01B\t\n" +
	"\a_reasonB\n" +
	"\n" +
	"\b_message\x1a$\n" +
	"\x06HostIP\x12\x13\n" +
	"\x02ip\x18\x01 \x01(\tH\x00R\x02ip\x88\x01\x01B\x05\n" +
	"\x03_ip\x1a\x9c\a\n" +
	"\tPodStatus\x12\x19\n" +
	"\x05phase\x18\x01 \x01(\tH\x00R\x05phase\x88\x01\x01\x12S\n" +
	"\n" +
	"conditions\x18\x02 \x03(\v23.chalk.kubernetes.v1.KubernetesPodData.PodConditionR\n" +
	"conditions\x12\x1d\n" +
	"\amessage\x18\x03 \x01(\tH\x01R\amessage\x88\x01\x01\x12\x1b\n" +
	"\x06reason\x18\x04 \x01(\tH\x02R\x06reason\x88\x01\x01\x123\n" +
	"\x13nominated_node_name\x18\v \x01(\tH\x03R\x11nominatedNodeName\x88\x01\x01\x12\x1c\n" +
	"\ahost_ip\x18\x05 \x01(\tH\x04R\x06hostIp\x88\x01\x01\x12H\n" +
	"\bhost_ips\x18\x10 \x03(\v2-.chalk.kubernetes.v1.KubernetesPodData.HostIPR\ahostIps\x12\x1a\n" +
	"\x06pod_ip\x18\x06 \x01(\tH\x05R\x05podIp\x88\x01\x01\x12\"\n" +
	"\n" +
	"start_time\x18\a \x01(\x03H\x06R\tstartTime\x88\x01\x01\x12n\n" +
	"\x17init_container_statuses\x18\n" +
	" \x03(\v26.chalk.kubernetes.v1.KubernetesPodData.ContainerStatusR\x15initContainerStatuses\x12e\n" +
	"\x12container_statuses\x18\b \x03(\v26.chalk.kubernetes.v1.KubernetesPodData.ContainerStatusR\x11containerStatuses\x12 \n" +
	"\tqos_class\x18\t \x01(\tH\aR\bqosClass\x88\x01\x01\x12x\n" +
	"\x1cephemeral_container_statuses\x18\r \x03(\v26.chalk.kubernetes.v1.KubernetesPodData.ContainerStatusR\x1aephemeralContainerStatuses\x12\x1b\n" +
	"\x06resize\x18\x0e \x01(\tH\bR\x06resize\x88\x01\x01B\b\n" +
	"\x06_phaseB\n" +
	"\n" +
	"\b_messageB\t\n" +
	"\a_reasonB\x16\n" +
	"\x14_nominated_node_nameB\n" +
	"\n" +
	"\b_host_ipB\t\n" +
	"\a_pod_ipB\r\n" +
	"\v_start_timeB\f\n" +
	"\n" +
	"_qos_classB\t\n" +
	"\a_resize\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a>\n" +
	"\x10AnnotationsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\xd5\x01\n" +
	"\x17com.chalk.kubernetes.v1B\tPodsProtoP\x01ZAgithub.com/chalk-ai/chalk-go/gen/chalk/kubernetes/v1;kubernetesv1\xa2\x02\x03CKX\xaa\x02\x13Chalk.Kubernetes.V1\xca\x02\x13Chalk\\Kubernetes\\V1\xe2\x02\x1fChalk\\Kubernetes\\V1\\GPBMetadata\xea\x02\x15Chalk::Kubernetes::V1b\x06proto3"

var (
	file_chalk_kubernetes_v1_pods_proto_rawDescOnce sync.Once
	file_chalk_kubernetes_v1_pods_proto_rawDescData []byte
)

func file_chalk_kubernetes_v1_pods_proto_rawDescGZIP() []byte {
	file_chalk_kubernetes_v1_pods_proto_rawDescOnce.Do(func() {
		file_chalk_kubernetes_v1_pods_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_chalk_kubernetes_v1_pods_proto_rawDesc), len(file_chalk_kubernetes_v1_pods_proto_rawDesc)))
	})
	return file_chalk_kubernetes_v1_pods_proto_rawDescData
}

var file_chalk_kubernetes_v1_pods_proto_msgTypes = make([]protoimpl.MessageInfo, 30)
var file_chalk_kubernetes_v1_pods_proto_goTypes = []any{
	(*KubernetesPodData)(nil),                          // 0: chalk.kubernetes.v1.KubernetesPodData
	(*KubernetesPodData_Volume)(nil),                   // 1: chalk.kubernetes.v1.KubernetesPodData.Volume
	(*KubernetesPodData_ClaimSource)(nil),              // 2: chalk.kubernetes.v1.KubernetesPodData.ClaimSource
	(*KubernetesPodData_PodResourceClaim)(nil),         // 3: chalk.kubernetes.v1.KubernetesPodData.PodResourceClaim
	(*KubernetesPodData_PodSpec)(nil),                  // 4: chalk.kubernetes.v1.KubernetesPodData.PodSpec
	(*KubernetesPodData_ContainerState)(nil),           // 5: chalk.kubernetes.v1.KubernetesPodData.ContainerState
	(*KubernetesPodData_ContainerStateRunning)(nil),    // 6: chalk.kubernetes.v1.KubernetesPodData.ContainerStateRunning
	(*KubernetesPodData_ContainerStateTerminated)(nil), // 7: chalk.kubernetes.v1.KubernetesPodData.ContainerStateTerminated
	(*KubernetesPodData_EnvVar)(nil),                   // 8: chalk.kubernetes.v1.KubernetesPodData.EnvVar
	(*KubernetesPodData_EnvVarSource)(nil),             // 9: chalk.kubernetes.v1.KubernetesPodData.EnvVarSource
	(*KubernetesPodData_ObjectFieldSelector)(nil),      // 10: chalk.kubernetes.v1.KubernetesPodData.ObjectFieldSelector
	(*KubernetesPodData_ResourceFieldSelector)(nil),    // 11: chalk.kubernetes.v1.KubernetesPodData.ResourceFieldSelector
	(*KubernetesPodData_ConfigMapKeySelector)(nil),     // 12: chalk.kubernetes.v1.KubernetesPodData.ConfigMapKeySelector
	(*KubernetesPodData_SecretKeySelector)(nil),        // 13: chalk.kubernetes.v1.KubernetesPodData.SecretKeySelector
	(*KubernetesPodData_EnvFromSource)(nil),            // 14: chalk.kubernetes.v1.KubernetesPodData.EnvFromSource
	(*KubernetesPodData_ConfigMapEnvSource)(nil),       // 15: chalk.kubernetes.v1.KubernetesPodData.ConfigMapEnvSource
	(*KubernetesPodData_SecretEnvSource)(nil),          // 16: chalk.kubernetes.v1.KubernetesPodData.SecretEnvSource
	(*KubernetesPodData_Container)(nil),                // 17: chalk.kubernetes.v1.KubernetesPodData.Container
	(*KubernetesPodData_ContainerStateWaiting)(nil),    // 18: chalk.kubernetes.v1.KubernetesPodData.ContainerStateWaiting
	(*KubernetesPodData_ContainerStatus)(nil),          // 19: chalk.kubernetes.v1.KubernetesPodData.ContainerStatus
	(*KubernetesPodData_Quantity)(nil),                 // 20: chalk.kubernetes.v1.KubernetesPodData.Quantity
	(*KubernetesPodData_ResourceRequirements)(nil),     // 21: chalk.kubernetes.v1.KubernetesPodData.ResourceRequirements
	(*KubernetesPodData_PodCondition)(nil),             // 22: chalk.kubernetes.v1.KubernetesPodData.PodCondition
	(*KubernetesPodData_HostIP)(nil),                   // 23: chalk.kubernetes.v1.KubernetesPodData.HostIP
	(*KubernetesPodData_PodStatus)(nil),                // 24: chalk.kubernetes.v1.KubernetesPodData.PodStatus
	nil,                                                // 25: chalk.kubernetes.v1.KubernetesPodData.LabelsEntry
	nil,                                                // 26: chalk.kubernetes.v1.KubernetesPodData.AnnotationsEntry
	nil,                                                // 27: chalk.kubernetes.v1.KubernetesPodData.PodSpec.NodeSelectorEntry
	nil,                                                // 28: chalk.kubernetes.v1.KubernetesPodData.ResourceRequirements.LimitsEntry
	nil,                                                // 29: chalk.kubernetes.v1.KubernetesPodData.ResourceRequirements.RequestsEntry
}
var file_chalk_kubernetes_v1_pods_proto_depIdxs = []int32{
	24, // 0: chalk.kubernetes.v1.KubernetesPodData.status:type_name -> chalk.kubernetes.v1.KubernetesPodData.PodStatus
	4,  // 1: chalk.kubernetes.v1.KubernetesPodData.spec:type_name -> chalk.kubernetes.v1.KubernetesPodData.PodSpec
	25, // 2: chalk.kubernetes.v1.KubernetesPodData.labels:type_name -> chalk.kubernetes.v1.KubernetesPodData.LabelsEntry
	26, // 3: chalk.kubernetes.v1.KubernetesPodData.annotations:type_name -> chalk.kubernetes.v1.KubernetesPodData.AnnotationsEntry
	2,  // 4: chalk.kubernetes.v1.KubernetesPodData.PodResourceClaim.source:type_name -> chalk.kubernetes.v1.KubernetesPodData.ClaimSource
	1,  // 5: chalk.kubernetes.v1.KubernetesPodData.PodSpec.volumes:type_name -> chalk.kubernetes.v1.KubernetesPodData.Volume
	17, // 6: chalk.kubernetes.v1.KubernetesPodData.PodSpec.init_containers:type_name -> chalk.kubernetes.v1.KubernetesPodData.Container
	17, // 7: chalk.kubernetes.v1.KubernetesPodData.PodSpec.containers:type_name -> chalk.kubernetes.v1.KubernetesPodData.Container
	27, // 8: chalk.kubernetes.v1.KubernetesPodData.PodSpec.node_selector:type_name -> chalk.kubernetes.v1.KubernetesPodData.PodSpec.NodeSelectorEntry
	3,  // 9: chalk.kubernetes.v1.KubernetesPodData.PodSpec.resource_claims:type_name -> chalk.kubernetes.v1.KubernetesPodData.PodResourceClaim
	18, // 10: chalk.kubernetes.v1.KubernetesPodData.ContainerState.waiting:type_name -> chalk.kubernetes.v1.KubernetesPodData.ContainerStateWaiting
	6,  // 11: chalk.kubernetes.v1.KubernetesPodData.ContainerState.running:type_name -> chalk.kubernetes.v1.KubernetesPodData.ContainerStateRunning
	7,  // 12: chalk.kubernetes.v1.KubernetesPodData.ContainerState.terminated:type_name -> chalk.kubernetes.v1.KubernetesPodData.ContainerStateTerminated
	9,  // 13: chalk.kubernetes.v1.KubernetesPodData.EnvVar.value_from:type_name -> chalk.kubernetes.v1.KubernetesPodData.EnvVarSource
	10, // 14: chalk.kubernetes.v1.KubernetesPodData.EnvVarSource.field_ref:type_name -> chalk.kubernetes.v1.KubernetesPodData.ObjectFieldSelector
	11, // 15: chalk.kubernetes.v1.KubernetesPodData.EnvVarSource.resource_field_ref:type_name -> chalk.kubernetes.v1.KubernetesPodData.ResourceFieldSelector
	12, // 16: chalk.kubernetes.v1.KubernetesPodData.EnvVarSource.config_map_key_ref:type_name -> chalk.kubernetes.v1.KubernetesPodData.ConfigMapKeySelector
	13, // 17: chalk.kubernetes.v1.KubernetesPodData.EnvVarSource.secret_key_ref:type_name -> chalk.kubernetes.v1.KubernetesPodData.SecretKeySelector
	20, // 18: chalk.kubernetes.v1.KubernetesPodData.ResourceFieldSelector.divisor:type_name -> chalk.kubernetes.v1.KubernetesPodData.Quantity
	15, // 19: chalk.kubernetes.v1.KubernetesPodData.EnvFromSource.config_map_ref:type_name -> chalk.kubernetes.v1.KubernetesPodData.ConfigMapEnvSource
	16, // 20: chalk.kubernetes.v1.KubernetesPodData.EnvFromSource.secret_ref:type_name -> chalk.kubernetes.v1.KubernetesPodData.SecretEnvSource
	14, // 21: chalk.kubernetes.v1.KubernetesPodData.Container.env_from:type_name -> chalk.kubernetes.v1.KubernetesPodData.EnvFromSource
	8,  // 22: chalk.kubernetes.v1.KubernetesPodData.Container.env:type_name -> chalk.kubernetes.v1.KubernetesPodData.EnvVar
	21, // 23: chalk.kubernetes.v1.KubernetesPodData.Container.resources:type_name -> chalk.kubernetes.v1.KubernetesPodData.ResourceRequirements
	5,  // 24: chalk.kubernetes.v1.KubernetesPodData.ContainerStatus.state:type_name -> chalk.kubernetes.v1.KubernetesPodData.ContainerState
	5,  // 25: chalk.kubernetes.v1.KubernetesPodData.ContainerStatus.last_state:type_name -> chalk.kubernetes.v1.KubernetesPodData.ContainerState
	28, // 26: chalk.kubernetes.v1.KubernetesPodData.ResourceRequirements.limits:type_name -> chalk.kubernetes.v1.KubernetesPodData.ResourceRequirements.LimitsEntry
	29, // 27: chalk.kubernetes.v1.KubernetesPodData.ResourceRequirements.requests:type_name -> chalk.kubernetes.v1.KubernetesPodData.ResourceRequirements.RequestsEntry
	22, // 28: chalk.kubernetes.v1.KubernetesPodData.PodStatus.conditions:type_name -> chalk.kubernetes.v1.KubernetesPodData.PodCondition
	23, // 29: chalk.kubernetes.v1.KubernetesPodData.PodStatus.host_ips:type_name -> chalk.kubernetes.v1.KubernetesPodData.HostIP
	19, // 30: chalk.kubernetes.v1.KubernetesPodData.PodStatus.init_container_statuses:type_name -> chalk.kubernetes.v1.KubernetesPodData.ContainerStatus
	19, // 31: chalk.kubernetes.v1.KubernetesPodData.PodStatus.container_statuses:type_name -> chalk.kubernetes.v1.KubernetesPodData.ContainerStatus
	19, // 32: chalk.kubernetes.v1.KubernetesPodData.PodStatus.ephemeral_container_statuses:type_name -> chalk.kubernetes.v1.KubernetesPodData.ContainerStatus
	20, // 33: chalk.kubernetes.v1.KubernetesPodData.ResourceRequirements.LimitsEntry.value:type_name -> chalk.kubernetes.v1.KubernetesPodData.Quantity
	20, // 34: chalk.kubernetes.v1.KubernetesPodData.ResourceRequirements.RequestsEntry.value:type_name -> chalk.kubernetes.v1.KubernetesPodData.Quantity
	35, // [35:35] is the sub-list for method output_type
	35, // [35:35] is the sub-list for method input_type
	35, // [35:35] is the sub-list for extension type_name
	35, // [35:35] is the sub-list for extension extendee
	0,  // [0:35] is the sub-list for field type_name
}

func init() { file_chalk_kubernetes_v1_pods_proto_init() }
func file_chalk_kubernetes_v1_pods_proto_init() {
	if File_chalk_kubernetes_v1_pods_proto != nil {
		return
	}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[2].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[3].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[4].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[5].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[7].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[8].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[9].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[11].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[12].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[13].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[14].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[15].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[16].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[17].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[18].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[19].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[20].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[22].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[23].OneofWrappers = []any{}
	file_chalk_kubernetes_v1_pods_proto_msgTypes[24].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_chalk_kubernetes_v1_pods_proto_rawDesc), len(file_chalk_kubernetes_v1_pods_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   30,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_chalk_kubernetes_v1_pods_proto_goTypes,
		DependencyIndexes: file_chalk_kubernetes_v1_pods_proto_depIdxs,
		MessageInfos:      file_chalk_kubernetes_v1_pods_proto_msgTypes,
	}.Build()
	File_chalk_kubernetes_v1_pods_proto = out.File
	file_chalk_kubernetes_v1_pods_proto_goTypes = nil
	file_chalk_kubernetes_v1_pods_proto_depIdxs = nil
}
