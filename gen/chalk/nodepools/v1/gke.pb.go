// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: chalk/nodepools/v1/gke.proto

package nodepoolsv1

import (
	code "google.golang.org/genproto/googleapis/rpc/code"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Strategy used for node pool update.
type NodePoolUpdateStrategy int32

const (
	// Default value if unset. GKE internally defaults the update strategy to
	// SURGE for unspecified strategies.
	NodePoolUpdateStrategy_NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED NodePoolUpdateStrategy = 0
	// blue-green upgrade.
	NodePoolUpdateStrategy_NODE_POOL_UPDATE_STRATEGY_BLUE_GREEN NodePoolUpdateStrategy = 2
	// SURGE is the traditional way of upgrade a node pool.
	// max_surge and max_unavailable determines the level of upgrade parallelism.
	NodePoolUpdateStrategy_NODE_POOL_UPDATE_STRATEGY_SURGE NodePoolUpdateStrategy = 3
)

// Enum value maps for NodePoolUpdateStrategy.
var (
	NodePoolUpdateStrategy_name = map[int32]string{
		0: "NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED",
		2: "NODE_POOL_UPDATE_STRATEGY_BLUE_GREEN",
		3: "NODE_POOL_UPDATE_STRATEGY_SURGE",
	}
	NodePoolUpdateStrategy_value = map[string]int32{
		"NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED": 0,
		"NODE_POOL_UPDATE_STRATEGY_BLUE_GREEN":  2,
		"NODE_POOL_UPDATE_STRATEGY_SURGE":       3,
	}
)

func (x NodePoolUpdateStrategy) Enum() *NodePoolUpdateStrategy {
	p := new(NodePoolUpdateStrategy)
	*p = x
	return p
}

func (x NodePoolUpdateStrategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NodePoolUpdateStrategy) Descriptor() protoreflect.EnumDescriptor {
	return file_chalk_nodepools_v1_gke_proto_enumTypes[0].Descriptor()
}

func (NodePoolUpdateStrategy) Type() protoreflect.EnumType {
	return &file_chalk_nodepools_v1_gke_proto_enumTypes[0]
}

func (x NodePoolUpdateStrategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NodePoolUpdateStrategy.Descriptor instead.
func (NodePoolUpdateStrategy) EnumDescriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{0}
}

// Code for each condition
type StatusCondition_Code int32

const (
	// UNKNOWN indicates a generic condition.
	StatusCondition_CODE_UNSPECIFIED StatusCondition_Code = 0
	// GCE_STOCKOUT indicates that Google Compute Engine resources are
	// temporarily unavailable.
	StatusCondition_CODE_GCE_STOCKOUT StatusCondition_Code = 1
	// GKE_SERVICE_ACCOUNT_DELETED indicates that the user deleted their robot
	// service account.
	StatusCondition_CODE_GKE_SERVICE_ACCOUNT_DELETED StatusCondition_Code = 2
	// Google Compute Engine quota was exceeded.
	StatusCondition_CODE_GCE_QUOTA_EXCEEDED StatusCondition_Code = 3
	// Cluster state was manually changed by an SRE due to a system logic error.
	StatusCondition_CODE_SET_BY_OPERATOR StatusCondition_Code = 4
	// Unable to perform an encrypt operation against the CloudKMS key used for
	// etcd level encryption.
	StatusCondition_CODE_CLOUD_KMS_KEY_ERROR StatusCondition_Code = 7
	// Cluster CA is expiring soon.
	StatusCondition_CODE_CA_EXPIRING StatusCondition_Code = 9
	// Node service account is missing permissions.
	StatusCondition_CODE_NODE_SERVICE_ACCOUNT_MISSING_PERMISSIONS StatusCondition_Code = 10
)

// Enum value maps for StatusCondition_Code.
var (
	StatusCondition_Code_name = map[int32]string{
		0:  "CODE_UNSPECIFIED",
		1:  "CODE_GCE_STOCKOUT",
		2:  "CODE_GKE_SERVICE_ACCOUNT_DELETED",
		3:  "CODE_GCE_QUOTA_EXCEEDED",
		4:  "CODE_SET_BY_OPERATOR",
		7:  "CODE_CLOUD_KMS_KEY_ERROR",
		9:  "CODE_CA_EXPIRING",
		10: "CODE_NODE_SERVICE_ACCOUNT_MISSING_PERMISSIONS",
	}
	StatusCondition_Code_value = map[string]int32{
		"CODE_UNSPECIFIED":                              0,
		"CODE_GCE_STOCKOUT":                             1,
		"CODE_GKE_SERVICE_ACCOUNT_DELETED":              2,
		"CODE_GCE_QUOTA_EXCEEDED":                       3,
		"CODE_SET_BY_OPERATOR":                          4,
		"CODE_CLOUD_KMS_KEY_ERROR":                      7,
		"CODE_CA_EXPIRING":                              9,
		"CODE_NODE_SERVICE_ACCOUNT_MISSING_PERMISSIONS": 10,
	}
)

func (x StatusCondition_Code) Enum() *StatusCondition_Code {
	p := new(StatusCondition_Code)
	*p = x
	return p
}

func (x StatusCondition_Code) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StatusCondition_Code) Descriptor() protoreflect.EnumDescriptor {
	return file_chalk_nodepools_v1_gke_proto_enumTypes[1].Descriptor()
}

func (StatusCondition_Code) Type() protoreflect.EnumType {
	return &file_chalk_nodepools_v1_gke_proto_enumTypes[1]
}

func (x StatusCondition_Code) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use StatusCondition_Code.Descriptor instead.
func (StatusCondition_Code) EnumDescriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{0, 0}
}

// Location policy specifies how zones are picked when scaling up the
// nodepool.
type NodePoolAutoscaling_LocationPolicy int32

const (
	// Not set.
	NodePoolAutoscaling_LOCATION_POLICY_UNSPECIFIED NodePoolAutoscaling_LocationPolicy = 0
	// BALANCED is a best effort policy that aims to balance the sizes of
	// different zones.
	NodePoolAutoscaling_LOCATION_POLICY_BALANCED NodePoolAutoscaling_LocationPolicy = 1
	// ANY policy picks zones that have the highest capacity available.
	NodePoolAutoscaling_LOCATION_POLICY_ANY NodePoolAutoscaling_LocationPolicy = 2
)

// Enum value maps for NodePoolAutoscaling_LocationPolicy.
var (
	NodePoolAutoscaling_LocationPolicy_name = map[int32]string{
		0: "LOCATION_POLICY_UNSPECIFIED",
		1: "LOCATION_POLICY_BALANCED",
		2: "LOCATION_POLICY_ANY",
	}
	NodePoolAutoscaling_LocationPolicy_value = map[string]int32{
		"LOCATION_POLICY_UNSPECIFIED": 0,
		"LOCATION_POLICY_BALANCED":    1,
		"LOCATION_POLICY_ANY":         2,
	}
)

func (x NodePoolAutoscaling_LocationPolicy) Enum() *NodePoolAutoscaling_LocationPolicy {
	p := new(NodePoolAutoscaling_LocationPolicy)
	*p = x
	return p
}

func (x NodePoolAutoscaling_LocationPolicy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NodePoolAutoscaling_LocationPolicy) Descriptor() protoreflect.EnumDescriptor {
	return file_chalk_nodepools_v1_gke_proto_enumTypes[2].Descriptor()
}

func (NodePoolAutoscaling_LocationPolicy) Type() protoreflect.EnumType {
	return &file_chalk_nodepools_v1_gke_proto_enumTypes[2]
}

func (x NodePoolAutoscaling_LocationPolicy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NodePoolAutoscaling_LocationPolicy.Descriptor instead.
func (NodePoolAutoscaling_LocationPolicy) EnumDescriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{1, 0}
}

// Possible values for Effect in taint.
type NodeTaint_Effect int32

const (
	// Not set
	NodeTaint_EFFECT_UNSPECIFIED NodeTaint_Effect = 0
	// NoSchedule
	NodeTaint_EFFECT_NO_SCHEDULE NodeTaint_Effect = 1
	// PreferNoSchedule
	NodeTaint_EFFECT_PREFER_NO_SCHEDULE NodeTaint_Effect = 2
	// NoExecute
	NodeTaint_EFFECT_NO_EXECUTE NodeTaint_Effect = 3
)

// Enum value maps for NodeTaint_Effect.
var (
	NodeTaint_Effect_name = map[int32]string{
		0: "EFFECT_UNSPECIFIED",
		1: "EFFECT_NO_SCHEDULE",
		2: "EFFECT_PREFER_NO_SCHEDULE",
		3: "EFFECT_NO_EXECUTE",
	}
	NodeTaint_Effect_value = map[string]int32{
		"EFFECT_UNSPECIFIED":        0,
		"EFFECT_NO_SCHEDULE":        1,
		"EFFECT_PREFER_NO_SCHEDULE": 2,
		"EFFECT_NO_EXECUTE":         3,
	}
)

func (x NodeTaint_Effect) Enum() *NodeTaint_Effect {
	p := new(NodeTaint_Effect)
	*p = x
	return p
}

func (x NodeTaint_Effect) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NodeTaint_Effect) Descriptor() protoreflect.EnumDescriptor {
	return file_chalk_nodepools_v1_gke_proto_enumTypes[3].Descriptor()
}

func (NodeTaint_Effect) Type() protoreflect.EnumType {
	return &file_chalk_nodepools_v1_gke_proto_enumTypes[3]
}

func (x NodeTaint_Effect) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NodeTaint_Effect.Descriptor instead.
func (NodeTaint_Effect) EnumDescriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{2, 0}
}

// LocalSsdEncryptionMode specifies the method used for encrypting the Local
// SSDs attached to the node.
type NodeConfig_LocalSsdEncryptionMode int32

const (
	// The given node will be encrypted using keys managed by Google
	// infrastructure and the keys will be deleted when the node is
	// deleted.
	NodeConfig_LOCAL_SSD_ENCRYPTION_MODE_UNSPECIFIED NodeConfig_LocalSsdEncryptionMode = 0
	// The given node will be encrypted using keys managed by Google
	// infrastructure and the keys will be deleted when the node is
	// deleted.
	NodeConfig_LOCAL_SSD_ENCRYPTION_MODE_STANDARD_ENCRYPTION NodeConfig_LocalSsdEncryptionMode = 1
	// The given node will opt-in for using ephemeral key for
	// encryption of Local SSDs.
	// The Local SSDs will not be able to recover data in case of node
	// crash.
	NodeConfig_LOCAL_SSD_ENCRYPTION_MODE_EPHEMERAL_KEY_ENCRYPTION NodeConfig_LocalSsdEncryptionMode = 2
)

// Enum value maps for NodeConfig_LocalSsdEncryptionMode.
var (
	NodeConfig_LocalSsdEncryptionMode_name = map[int32]string{
		0: "LOCAL_SSD_ENCRYPTION_MODE_UNSPECIFIED",
		1: "LOCAL_SSD_ENCRYPTION_MODE_STANDARD_ENCRYPTION",
		2: "LOCAL_SSD_ENCRYPTION_MODE_EPHEMERAL_KEY_ENCRYPTION",
	}
	NodeConfig_LocalSsdEncryptionMode_value = map[string]int32{
		"LOCAL_SSD_ENCRYPTION_MODE_UNSPECIFIED":              0,
		"LOCAL_SSD_ENCRYPTION_MODE_STANDARD_ENCRYPTION":      1,
		"LOCAL_SSD_ENCRYPTION_MODE_EPHEMERAL_KEY_ENCRYPTION": 2,
	}
)

func (x NodeConfig_LocalSsdEncryptionMode) Enum() *NodeConfig_LocalSsdEncryptionMode {
	p := new(NodeConfig_LocalSsdEncryptionMode)
	*p = x
	return p
}

func (x NodeConfig_LocalSsdEncryptionMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NodeConfig_LocalSsdEncryptionMode) Descriptor() protoreflect.EnumDescriptor {
	return file_chalk_nodepools_v1_gke_proto_enumTypes[4].Descriptor()
}

func (NodeConfig_LocalSsdEncryptionMode) Type() protoreflect.EnumType {
	return &file_chalk_nodepools_v1_gke_proto_enumTypes[4]
}

func (x NodeConfig_LocalSsdEncryptionMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NodeConfig_LocalSsdEncryptionMode.Descriptor instead.
func (NodeConfig_LocalSsdEncryptionMode) EnumDescriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{7, 0}
}

// Possible effective cgroup modes for the node.
type NodeConfig_EffectiveCgroupMode int32

const (
	// EFFECTIVE_CGROUP_MODE_UNSPECIFIED means the cgroup configuration for the
	// node pool is unspecified, i.e. the node pool is a Windows node pool.
	NodeConfig_EFFECTIVE_CGROUP_MODE_UNSPECIFIED NodeConfig_EffectiveCgroupMode = 0
	// CGROUP_MODE_V1 means the node pool is configured to use cgroupv1 for the
	// cgroup configuration.
	NodeConfig_EFFECTIVE_CGROUP_MODE_V1 NodeConfig_EffectiveCgroupMode = 1
	// CGROUP_MODE_V2 means the node pool is configured to use cgroupv2 for the
	// cgroup configuration.
	NodeConfig_EFFECTIVE_CGROUP_MODE_V2 NodeConfig_EffectiveCgroupMode = 2
)

// Enum value maps for NodeConfig_EffectiveCgroupMode.
var (
	NodeConfig_EffectiveCgroupMode_name = map[int32]string{
		0: "EFFECTIVE_CGROUP_MODE_UNSPECIFIED",
		1: "EFFECTIVE_CGROUP_MODE_V1",
		2: "EFFECTIVE_CGROUP_MODE_V2",
	}
	NodeConfig_EffectiveCgroupMode_value = map[string]int32{
		"EFFECTIVE_CGROUP_MODE_UNSPECIFIED": 0,
		"EFFECTIVE_CGROUP_MODE_V1":          1,
		"EFFECTIVE_CGROUP_MODE_V2":          2,
	}
)

func (x NodeConfig_EffectiveCgroupMode) Enum() *NodeConfig_EffectiveCgroupMode {
	p := new(NodeConfig_EffectiveCgroupMode)
	*p = x
	return p
}

func (x NodeConfig_EffectiveCgroupMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NodeConfig_EffectiveCgroupMode) Descriptor() protoreflect.EnumDescriptor {
	return file_chalk_nodepools_v1_gke_proto_enumTypes[5].Descriptor()
}

func (NodeConfig_EffectiveCgroupMode) Type() protoreflect.EnumType {
	return &file_chalk_nodepools_v1_gke_proto_enumTypes[5]
}

func (x NodeConfig_EffectiveCgroupMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NodeConfig_EffectiveCgroupMode.Descriptor instead.
func (NodeConfig_EffectiveCgroupMode) EnumDescriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{7, 1}
}

// The current status of the node pool instance.
type GKENodePool_Status int32

const (
	// Not set.
	GKENodePool_STATUS_UNSPECIFIED GKENodePool_Status = 0
	// The PROVISIONING state indicates the node pool is being created.
	GKENodePool_STATUS_PROVISIONING GKENodePool_Status = 1
	// The RUNNING state indicates the node pool has been created
	// and is fully usable.
	GKENodePool_STATUS_RUNNING GKENodePool_Status = 2
	// The RUNNING_WITH_ERROR state indicates the node pool has been created
	// and is partially usable. Some error state has occurred and some
	// functionality may be impaired. Customer may need to reissue a request
	// or trigger a new update.
	GKENodePool_STATUS_RUNNING_WITH_ERROR GKENodePool_Status = 3
	// The RECONCILING state indicates that some work is actively being done on
	// the node pool, such as upgrading node software. Details can
	// be found in the `statusMessage` field.
	GKENodePool_STATUS_RECONCILING GKENodePool_Status = 4
	// The STOPPING state indicates the node pool is being deleted.
	GKENodePool_STATUS_STOPPING GKENodePool_Status = 5
	// The ERROR state indicates the node pool may be unusable. Details
	// can be found in the `statusMessage` field.
	GKENodePool_STATUS_ERROR GKENodePool_Status = 6
)

// Enum value maps for GKENodePool_Status.
var (
	GKENodePool_Status_name = map[int32]string{
		0: "STATUS_UNSPECIFIED",
		1: "STATUS_PROVISIONING",
		2: "STATUS_RUNNING",
		3: "STATUS_RUNNING_WITH_ERROR",
		4: "STATUS_RECONCILING",
		5: "STATUS_STOPPING",
		6: "STATUS_ERROR",
	}
	GKENodePool_Status_value = map[string]int32{
		"STATUS_UNSPECIFIED":        0,
		"STATUS_PROVISIONING":       1,
		"STATUS_RUNNING":            2,
		"STATUS_RUNNING_WITH_ERROR": 3,
		"STATUS_RECONCILING":        4,
		"STATUS_STOPPING":           5,
		"STATUS_ERROR":              6,
	}
)

func (x GKENodePool_Status) Enum() *GKENodePool_Status {
	p := new(GKENodePool_Status)
	*p = x
	return p
}

func (x GKENodePool_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GKENodePool_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_chalk_nodepools_v1_gke_proto_enumTypes[6].Descriptor()
}

func (GKENodePool_Status) Type() protoreflect.EnumType {
	return &file_chalk_nodepools_v1_gke_proto_enumTypes[6]
}

func (x GKENodePool_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GKENodePool_Status.Descriptor instead.
func (GKENodePool_Status) EnumDescriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{9, 0}
}

// Phase represents the different stages blue-green upgrade is running in.
type GKENodePool_UpdateInfo_BlueGreenInfo_Phase int32

const (
	// Unspecified phase.
	GKENodePool_UpdateInfo_BlueGreenInfo_PHASE_UNSPECIFIED GKENodePool_UpdateInfo_BlueGreenInfo_Phase = 0
	// blue-green upgrade has been initiated.
	GKENodePool_UpdateInfo_BlueGreenInfo_PHASE_UPDATE_STARTED GKENodePool_UpdateInfo_BlueGreenInfo_Phase = 1
	// Start creating green pool nodes.
	GKENodePool_UpdateInfo_BlueGreenInfo_PHASE_CREATING_GREEN_POOL GKENodePool_UpdateInfo_BlueGreenInfo_Phase = 2
	// Start cordoning blue pool nodes.
	GKENodePool_UpdateInfo_BlueGreenInfo_PHASE_CORDONING_BLUE_POOL GKENodePool_UpdateInfo_BlueGreenInfo_Phase = 3
	// Start draining blue pool nodes.
	GKENodePool_UpdateInfo_BlueGreenInfo_PHASE_DRAINING_BLUE_POOL GKENodePool_UpdateInfo_BlueGreenInfo_Phase = 4
	// Start soaking time after draining entire blue pool.
	GKENodePool_UpdateInfo_BlueGreenInfo_PHASE_NODE_POOL_SOAKING GKENodePool_UpdateInfo_BlueGreenInfo_Phase = 5
	// Start deleting blue nodes.
	GKENodePool_UpdateInfo_BlueGreenInfo_PHASE_DELETING_BLUE_POOL GKENodePool_UpdateInfo_BlueGreenInfo_Phase = 6
	// Rollback has been initiated.
	GKENodePool_UpdateInfo_BlueGreenInfo_PHASE_ROLLBACK_STARTED GKENodePool_UpdateInfo_BlueGreenInfo_Phase = 7
)

// Enum value maps for GKENodePool_UpdateInfo_BlueGreenInfo_Phase.
var (
	GKENodePool_UpdateInfo_BlueGreenInfo_Phase_name = map[int32]string{
		0: "PHASE_UNSPECIFIED",
		1: "PHASE_UPDATE_STARTED",
		2: "PHASE_CREATING_GREEN_POOL",
		3: "PHASE_CORDONING_BLUE_POOL",
		4: "PHASE_DRAINING_BLUE_POOL",
		5: "PHASE_NODE_POOL_SOAKING",
		6: "PHASE_DELETING_BLUE_POOL",
		7: "PHASE_ROLLBACK_STARTED",
	}
	GKENodePool_UpdateInfo_BlueGreenInfo_Phase_value = map[string]int32{
		"PHASE_UNSPECIFIED":         0,
		"PHASE_UPDATE_STARTED":      1,
		"PHASE_CREATING_GREEN_POOL": 2,
		"PHASE_CORDONING_BLUE_POOL": 3,
		"PHASE_DRAINING_BLUE_POOL":  4,
		"PHASE_NODE_POOL_SOAKING":   5,
		"PHASE_DELETING_BLUE_POOL":  6,
		"PHASE_ROLLBACK_STARTED":    7,
	}
)

func (x GKENodePool_UpdateInfo_BlueGreenInfo_Phase) Enum() *GKENodePool_UpdateInfo_BlueGreenInfo_Phase {
	p := new(GKENodePool_UpdateInfo_BlueGreenInfo_Phase)
	*p = x
	return p
}

func (x GKENodePool_UpdateInfo_BlueGreenInfo_Phase) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GKENodePool_UpdateInfo_BlueGreenInfo_Phase) Descriptor() protoreflect.EnumDescriptor {
	return file_chalk_nodepools_v1_gke_proto_enumTypes[7].Descriptor()
}

func (GKENodePool_UpdateInfo_BlueGreenInfo_Phase) Type() protoreflect.EnumType {
	return &file_chalk_nodepools_v1_gke_proto_enumTypes[7]
}

func (x GKENodePool_UpdateInfo_BlueGreenInfo_Phase) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GKENodePool_UpdateInfo_BlueGreenInfo_Phase.Descriptor instead.
func (GKENodePool_UpdateInfo_BlueGreenInfo_Phase) EnumDescriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{9, 1, 0, 0}
}

// Type defines the type of placement policy.
type GKENodePool_PlacementPolicy_Type int32

const (
	// TYPE_UNSPECIFIED specifies no requirements on nodes
	// placement.
	GKENodePool_PlacementPolicy_TYPE_UNSPECIFIED GKENodePool_PlacementPolicy_Type = 0
	// COMPACT specifies node placement in the same availability domain to
	// ensure low communication latency.
	GKENodePool_PlacementPolicy_TYPE_COMPACT GKENodePool_PlacementPolicy_Type = 1
)

// Enum value maps for GKENodePool_PlacementPolicy_Type.
var (
	GKENodePool_PlacementPolicy_Type_name = map[int32]string{
		0: "TYPE_UNSPECIFIED",
		1: "TYPE_COMPACT",
	}
	GKENodePool_PlacementPolicy_Type_value = map[string]int32{
		"TYPE_UNSPECIFIED": 0,
		"TYPE_COMPACT":     1,
	}
)

func (x GKENodePool_PlacementPolicy_Type) Enum() *GKENodePool_PlacementPolicy_Type {
	p := new(GKENodePool_PlacementPolicy_Type)
	*p = x
	return p
}

func (x GKENodePool_PlacementPolicy_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GKENodePool_PlacementPolicy_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_chalk_nodepools_v1_gke_proto_enumTypes[8].Descriptor()
}

func (GKENodePool_PlacementPolicy_Type) Type() protoreflect.EnumType {
	return &file_chalk_nodepools_v1_gke_proto_enumTypes[8]
}

func (x GKENodePool_PlacementPolicy_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GKENodePool_PlacementPolicy_Type.Descriptor instead.
func (GKENodePool_PlacementPolicy_Type) EnumDescriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{9, 2, 0}
}

// StatusCondition describes why a cluster or a node pool has a certain status
// (e.g., ERROR or DEGRADED).
type StatusCondition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Machine-friendly representation of the condition
	// Deprecated. Use canonical_code instead.
	//
	// Deprecated: Marked as deprecated in chalk/nodepools/v1/gke.proto.
	Code StatusCondition_Code `protobuf:"varint,1,opt,name=code,proto3,enum=chalk.nodepools.v1.StatusCondition_Code" json:"code,omitempty"`
	// Human-friendly representation of the condition
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// Canonical code of the condition.
	// has red underline but appears to work
	CanonicalCode code.Code `protobuf:"varint,3,opt,name=canonical_code,json=canonicalCode,proto3,enum=google.rpc.Code" json:"canonical_code,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StatusCondition) Reset() {
	*x = StatusCondition{}
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatusCondition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatusCondition) ProtoMessage() {}

func (x *StatusCondition) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatusCondition.ProtoReflect.Descriptor instead.
func (*StatusCondition) Descriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{0}
}

// Deprecated: Marked as deprecated in chalk/nodepools/v1/gke.proto.
func (x *StatusCondition) GetCode() StatusCondition_Code {
	if x != nil {
		return x.Code
	}
	return StatusCondition_CODE_UNSPECIFIED
}

func (x *StatusCondition) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *StatusCondition) GetCanonicalCode() code.Code {
	if x != nil {
		return x.CanonicalCode
	}
	return code.Code(0)
}

// NodePoolAutoscaling contains information required by cluster autoscaler to
// adjust the size of the node pool to the current cluster usage.
type NodePoolAutoscaling struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Is autoscaling enabled for this node pool.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Minimum number of nodes for one location in the node pool. Must be greater
	// than or equal to 0 and less than or equal to max_node_count.
	MinNodeCount int32 `protobuf:"varint,2,opt,name=min_node_count,json=minNodeCount,proto3" json:"min_node_count,omitempty"`
	// Maximum number of nodes for one location in the node pool. Must be >=
	// min_node_count. There has to be enough quota to scale up the cluster.
	MaxNodeCount int32 `protobuf:"varint,3,opt,name=max_node_count,json=maxNodeCount,proto3" json:"max_node_count,omitempty"`
	// Can this node pool be deleted automatically.
	Autoprovisioned bool `protobuf:"varint,4,opt,name=autoprovisioned,proto3" json:"autoprovisioned,omitempty"`
	// Location policy used when scaling up a nodepool.
	LocationPolicy NodePoolAutoscaling_LocationPolicy `protobuf:"varint,5,opt,name=location_policy,json=locationPolicy,proto3,enum=chalk.nodepools.v1.NodePoolAutoscaling_LocationPolicy" json:"location_policy,omitempty"`
	// Minimum number of nodes in the node pool. Must be greater than or equal
	// to 0 and less than or equal to total_max_node_count.
	// The total_*_node_count fields are mutually exclusive with the *_node_count
	// fields.
	TotalMinNodeCount int32 `protobuf:"varint,6,opt,name=total_min_node_count,json=totalMinNodeCount,proto3" json:"total_min_node_count,omitempty"`
	// Maximum number of nodes in the node pool. Must be greater than or equal to
	// total_min_node_count. There has to be enough quota to scale up the cluster.
	// The total_*_node_count fields are mutually exclusive with the *_node_count
	// fields.
	TotalMaxNodeCount int32 `protobuf:"varint,7,opt,name=total_max_node_count,json=totalMaxNodeCount,proto3" json:"total_max_node_count,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *NodePoolAutoscaling) Reset() {
	*x = NodePoolAutoscaling{}
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodePoolAutoscaling) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodePoolAutoscaling) ProtoMessage() {}

func (x *NodePoolAutoscaling) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodePoolAutoscaling.ProtoReflect.Descriptor instead.
func (*NodePoolAutoscaling) Descriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{1}
}

func (x *NodePoolAutoscaling) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *NodePoolAutoscaling) GetMinNodeCount() int32 {
	if x != nil {
		return x.MinNodeCount
	}
	return 0
}

func (x *NodePoolAutoscaling) GetMaxNodeCount() int32 {
	if x != nil {
		return x.MaxNodeCount
	}
	return 0
}

func (x *NodePoolAutoscaling) GetAutoprovisioned() bool {
	if x != nil {
		return x.Autoprovisioned
	}
	return false
}

func (x *NodePoolAutoscaling) GetLocationPolicy() NodePoolAutoscaling_LocationPolicy {
	if x != nil {
		return x.LocationPolicy
	}
	return NodePoolAutoscaling_LOCATION_POLICY_UNSPECIFIED
}

func (x *NodePoolAutoscaling) GetTotalMinNodeCount() int32 {
	if x != nil {
		return x.TotalMinNodeCount
	}
	return 0
}

func (x *NodePoolAutoscaling) GetTotalMaxNodeCount() int32 {
	if x != nil {
		return x.TotalMaxNodeCount
	}
	return 0
}

// Kubernetes taint is composed of three fields: key, value, and effect. Effect
// can only be one of three types:  NoSchedule, PreferNoSchedule or NoExecute.
//
// See
// [here](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration)
// for more information, including usage and the valid values.
type NodeTaint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Key for taint.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Value for taint.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Effect for taint.
	Effect        NodeTaint_Effect `protobuf:"varint,3,opt,name=effect,proto3,enum=chalk.nodepools.v1.NodeTaint_Effect" json:"effect,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeTaint) Reset() {
	*x = NodeTaint{}
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeTaint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeTaint) ProtoMessage() {}

func (x *NodeTaint) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeTaint.ProtoReflect.Descriptor instead.
func (*NodeTaint) Descriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{2}
}

func (x *NodeTaint) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *NodeTaint) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *NodeTaint) GetEffect() NodeTaint_Effect {
	if x != nil {
		return x.Effect
	}
	return NodeTaint_EFFECT_UNSPECIFIED
}

// Constraints applied to pods.
type MaxPodsConstraint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Constraint enforced on the max num of pods per node.
	MaxPodsPerNode int64 `protobuf:"varint,1,opt,name=max_pods_per_node,json=maxPodsPerNode,proto3" json:"max_pods_per_node,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *MaxPodsConstraint) Reset() {
	*x = MaxPodsConstraint{}
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MaxPodsConstraint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MaxPodsConstraint) ProtoMessage() {}

func (x *MaxPodsConstraint) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MaxPodsConstraint.ProtoReflect.Descriptor instead.
func (*MaxPodsConstraint) Descriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{3}
}

func (x *MaxPodsConstraint) GetMaxPodsPerNode() int64 {
	if x != nil {
		return x.MaxPodsPerNode
	}
	return 0
}

// Best effort provisioning.
type BestEffortProvisioning struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// When this is enabled, cluster/node pool creations will ignore non-fatal
	// errors like stockout to best provision as many nodes as possible right now
	// and eventually bring up all target number of nodes
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Minimum number of nodes to be provisioned to be considered as succeeded,
	// and the rest of nodes will be provisioned gradually and eventually when
	// stockout issue has been resolved.
	MinProvisionNodes int32 `protobuf:"varint,2,opt,name=min_provision_nodes,json=minProvisionNodes,proto3" json:"min_provision_nodes,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *BestEffortProvisioning) Reset() {
	*x = BestEffortProvisioning{}
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BestEffortProvisioning) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BestEffortProvisioning) ProtoMessage() {}

func (x *BestEffortProvisioning) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BestEffortProvisioning.ProtoReflect.Descriptor instead.
func (*BestEffortProvisioning) Descriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{4}
}

func (x *BestEffortProvisioning) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *BestEffortProvisioning) GetMinProvisionNodes() int32 {
	if x != nil {
		return x.MinProvisionNodes
	}
	return 0
}

// NodeManagement defines the set of node management services turned on for the
// node pool.
type NodeManagement struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A flag that specifies whether node auto-upgrade is enabled for the node
	// pool. If enabled, node auto-upgrade helps keep the nodes in your node pool
	// up to date with the latest release version of Kubernetes.
	AutoUpgrade bool `protobuf:"varint,1,opt,name=auto_upgrade,json=autoUpgrade,proto3" json:"auto_upgrade,omitempty"`
	// A flag that specifies whether the node auto-repair is enabled for the node
	// pool. If enabled, the nodes in this node pool will be monitored and, if
	// they fail health checks too many times, an automatic repair action will be
	// triggered.
	AutoRepair bool `protobuf:"varint,2,opt,name=auto_repair,json=autoRepair,proto3" json:"auto_repair,omitempty"`
	// Specifies the Auto Upgrade knobs for the node pool.
	UpgradeOptions *AutoUpgradeOptions `protobuf:"bytes,10,opt,name=upgrade_options,json=upgradeOptions,proto3" json:"upgrade_options,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *NodeManagement) Reset() {
	*x = NodeManagement{}
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeManagement) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeManagement) ProtoMessage() {}

func (x *NodeManagement) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeManagement.ProtoReflect.Descriptor instead.
func (*NodeManagement) Descriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{5}
}

func (x *NodeManagement) GetAutoUpgrade() bool {
	if x != nil {
		return x.AutoUpgrade
	}
	return false
}

func (x *NodeManagement) GetAutoRepair() bool {
	if x != nil {
		return x.AutoRepair
	}
	return false
}

func (x *NodeManagement) GetUpgradeOptions() *AutoUpgradeOptions {
	if x != nil {
		return x.UpgradeOptions
	}
	return nil
}

// AutoUpgradeOptions defines the set of options for the user to control how
// the Auto Upgrades will proceed.
type AutoUpgradeOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Output only. This field is set when upgrades are about to commence
	// with the approximate start time for the upgrades, in
	// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
	AutoUpgradeStartTime string `protobuf:"bytes,1,opt,name=auto_upgrade_start_time,json=autoUpgradeStartTime,proto3" json:"auto_upgrade_start_time,omitempty"`
	// Output only. This field is set when upgrades are about to commence
	// with the description of the upgrade.
	Description   string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AutoUpgradeOptions) Reset() {
	*x = AutoUpgradeOptions{}
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutoUpgradeOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoUpgradeOptions) ProtoMessage() {}

func (x *AutoUpgradeOptions) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoUpgradeOptions.ProtoReflect.Descriptor instead.
func (*AutoUpgradeOptions) Descriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{6}
}

func (x *AutoUpgradeOptions) GetAutoUpgradeStartTime() string {
	if x != nil {
		return x.AutoUpgradeStartTime
	}
	return ""
}

func (x *AutoUpgradeOptions) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

// Parameters that describe the nodes in a cluster.
//
// GKE Autopilot clusters do not
// recognize parameters in `NodeConfig`. Use
// [AutoprovisioningNodePoolDefaults][google.container.v1.AutoprovisioningNodePoolDefaults]
// instead.
type NodeConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of a Google Compute Engine [machine
	// type](https://cloud.google.com/compute/docs/machine-types)
	//
	// If unspecified, the default machine type is `e2-medium`.
	MachineType string `protobuf:"bytes,1,opt,name=machine_type,json=machineType,proto3" json:"machine_type,omitempty"`
	// Size of the disk attached to each node, specified in GB.
	// The smallest allowed disk size is 10GB.
	//
	// If unspecified, the default disk size is 100GB.
	DiskSizeGb int32 `protobuf:"varint,2,opt,name=disk_size_gb,json=diskSizeGb,proto3" json:"disk_size_gb,omitempty"`
	// The set of Google API scopes to be made available on all of the
	// node VMs under the "default" service account.
	//
	// The following scopes are recommended, but not required, and by default are
	// not included:
	//
	// * `https://www.googleapis.com/auth/compute` is required for mounting
	// persistent storage on your nodes.
	// * `https://www.googleapis.com/auth/devstorage.read_only` is required for
	// communicating with **gcr.io**
	// (the [Google Container
	// Registry](https://cloud.google.com/container-registry/)).
	//
	// If unspecified, no scopes are added, unless Cloud Logging or Cloud
	// Monitoring are enabled, in which case their required scopes will be added.
	OauthScopes []string `protobuf:"bytes,3,rep,name=oauth_scopes,json=oauthScopes,proto3" json:"oauth_scopes,omitempty"`
	// The Google Cloud Platform Service Account to be used by the node VMs.
	// Specify the email address of the Service Account; otherwise, if no Service
	// Account is specified, the "default" service account is used.
	ServiceAccount string `protobuf:"bytes,9,opt,name=service_account,json=serviceAccount,proto3" json:"service_account,omitempty"`
	// The metadata key/value pairs assigned to instances in the cluster.
	//
	// Keys must conform to the regexp `[a-zA-Z0-9-_]+` and be less than 128 bytes
	// in length. These are reflected as part of a URL in the metadata server.
	// Additionally, to avoid ambiguity, keys must not conflict with any other
	// metadata keys for the project or be one of the reserved keys:
	//
	//   - "cluster-location"
	//   - "cluster-name"
	//   - "cluster-uid"
	//   - "configure-sh"
	//   - "containerd-configure-sh"
	//   - "enable-os-login"
	//   - "gci-ensure-gke-docker"
	//   - "gci-metrics-enabled"
	//   - "gci-update-strategy"
	//   - "instance-template"
	//   - "kube-env"
	//   - "startup-script"
	//   - "user-data"
	//   - "disable-address-manager"
	//   - "windows-startup-script-ps1"
	//   - "common-psm1"
	//   - "k8s-node-setup-psm1"
	//   - "install-ssh-psm1"
	//   - "user-profile-psm1"
	//
	// Values are free-form strings, and only have meaning as interpreted by
	// the image running in the instance. The only restriction placed on them is
	// that each value's size must be less than or equal to 32 KB.
	//
	// The total size of all keys and values must be less than 512 KB.
	Metadata map[string]string `protobuf:"bytes,4,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The image type to use for this node. Note that for a given image type,
	// the latest version of it will be used. Please see
	// https://cloud.google.com/kubernetes-engine/docs/concepts/node-images for
	// available image types.
	ImageType string `protobuf:"bytes,5,opt,name=image_type,json=imageType,proto3" json:"image_type,omitempty"`
	// The map of Kubernetes labels (key/value pairs) to be applied to each node.
	// These will added in addition to any default label(s) that
	// Kubernetes may apply to the node.
	// In case of conflict in label keys, the applied set may differ depending on
	// the Kubernetes version -- it's best to assume the behavior is undefined
	// and conflicts should be avoided.
	// For more information, including usage and the valid values, see:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
	Labels map[string]string `protobuf:"bytes,6,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The number of local SSD disks to be attached to the node.
	//
	// The limit for this value is dependent upon the maximum number of
	// disks available on a machine per zone. See:
	// https://cloud.google.com/compute/docs/disks/local-ssd
	// for more information.
	LocalSsdCount int32 `protobuf:"varint,7,opt,name=local_ssd_count,json=localSsdCount,proto3" json:"local_ssd_count,omitempty"`
	// The list of instance tags applied to all nodes. Tags are used to identify
	// valid sources or targets for network firewalls and are specified by
	// the client during cluster or node pool creation. Each tag within the list
	// must comply with RFC1035.
	Tags []string `protobuf:"bytes,8,rep,name=tags,proto3" json:"tags,omitempty"`
	// Whether the nodes are created as preemptible VM instances. See:
	// https://cloud.google.com/compute/docs/instances/preemptible for more
	// information about preemptible VM instances.
	Preemptible bool `protobuf:"varint,10,opt,name=preemptible,proto3" json:"preemptible,omitempty"`
	// Type of the disk attached to each node (e.g. 'pd-standard', 'pd-ssd' or
	// 'pd-balanced')
	//
	// If unspecified, the default disk type is 'pd-standard'
	DiskType string `protobuf:"bytes,12,opt,name=disk_type,json=diskType,proto3" json:"disk_type,omitempty"`
	// Minimum CPU platform to be used by this instance. The instance may be
	// scheduled on the specified or newer CPU platform. Applicable values are the
	// friendly names of CPU platforms, such as
	// `minCpuPlatform: "Intel Haswell"` or
	// `minCpuPlatform: "Intel Sandy Bridge"`. For more
	// information, read [how to specify min CPU
	// platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
	MinCpuPlatform string `protobuf:"bytes,13,opt,name=min_cpu_platform,json=minCpuPlatform,proto3" json:"min_cpu_platform,omitempty"`
	// List of kubernetes taints to be applied to each node.
	//
	// For more information, including usage and the valid values, see:
	// https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
	Taints []*NodeTaint `protobuf:"bytes,15,rep,name=taints,proto3" json:"taints,omitempty"`
	// Setting this field will assign instances of this
	// pool to run on the specified node group. This is useful for running
	// workloads on [sole tenant
	// nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
	NodeGroup string `protobuf:"bytes,18,opt,name=node_group,json=nodeGroup,proto3" json:"node_group,omitempty"`
	// The Customer Managed Encryption Key used to encrypt the boot disk attached
	// to each node in the node pool. This should be of the form
	// projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME].
	// For more information about protecting resources with Cloud KMS Keys please
	// see:
	// https://cloud.google.com/compute/docs/disks/customer-managed-encryption
	BootDiskKmsKey string `protobuf:"bytes,23,opt,name=boot_disk_kms_key,json=bootDiskKmsKey,proto3" json:"boot_disk_kms_key,omitempty"`
	// Spot flag for enabling Spot VM, which is a rebrand of
	// the existing preemptible flag.
	Spot bool `protobuf:"varint,32,opt,name=spot,proto3" json:"spot,omitempty"`
	// The resource labels for the node pool to use to annotate any related
	// Google Compute Engine resources.
	ResourceLabels map[string]string `protobuf:"bytes,37,rep,name=resource_labels,json=resourceLabels,proto3" json:"resource_labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Specifies which method should be used for encrypting the
	// Local SSDs attached to the node.
	LocalSsdEncryptionMode *NodeConfig_LocalSsdEncryptionMode `protobuf:"varint,54,opt,name=local_ssd_encryption_mode,json=localSsdEncryptionMode,proto3,enum=chalk.nodepools.v1.NodeConfig_LocalSsdEncryptionMode,oneof" json:"local_ssd_encryption_mode,omitempty"`
	// Output only. effective_cgroup_mode is the cgroup mode actually used by the
	// node pool. It is determined by the cgroup mode specified in the
	// LinuxNodeConfig or the default cgroup mode based on the cluster creation
	// version.
	EffectiveCgroupMode NodeConfig_EffectiveCgroupMode `protobuf:"varint,55,opt,name=effective_cgroup_mode,json=effectiveCgroupMode,proto3,enum=chalk.nodepools.v1.NodeConfig_EffectiveCgroupMode" json:"effective_cgroup_mode,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *NodeConfig) Reset() {
	*x = NodeConfig{}
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeConfig) ProtoMessage() {}

func (x *NodeConfig) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeConfig.ProtoReflect.Descriptor instead.
func (*NodeConfig) Descriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{7}
}

func (x *NodeConfig) GetMachineType() string {
	if x != nil {
		return x.MachineType
	}
	return ""
}

func (x *NodeConfig) GetDiskSizeGb() int32 {
	if x != nil {
		return x.DiskSizeGb
	}
	return 0
}

func (x *NodeConfig) GetOauthScopes() []string {
	if x != nil {
		return x.OauthScopes
	}
	return nil
}

func (x *NodeConfig) GetServiceAccount() string {
	if x != nil {
		return x.ServiceAccount
	}
	return ""
}

func (x *NodeConfig) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *NodeConfig) GetImageType() string {
	if x != nil {
		return x.ImageType
	}
	return ""
}

func (x *NodeConfig) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *NodeConfig) GetLocalSsdCount() int32 {
	if x != nil {
		return x.LocalSsdCount
	}
	return 0
}

func (x *NodeConfig) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *NodeConfig) GetPreemptible() bool {
	if x != nil {
		return x.Preemptible
	}
	return false
}

func (x *NodeConfig) GetDiskType() string {
	if x != nil {
		return x.DiskType
	}
	return ""
}

func (x *NodeConfig) GetMinCpuPlatform() string {
	if x != nil {
		return x.MinCpuPlatform
	}
	return ""
}

func (x *NodeConfig) GetTaints() []*NodeTaint {
	if x != nil {
		return x.Taints
	}
	return nil
}

func (x *NodeConfig) GetNodeGroup() string {
	if x != nil {
		return x.NodeGroup
	}
	return ""
}

func (x *NodeConfig) GetBootDiskKmsKey() string {
	if x != nil {
		return x.BootDiskKmsKey
	}
	return ""
}

func (x *NodeConfig) GetSpot() bool {
	if x != nil {
		return x.Spot
	}
	return false
}

func (x *NodeConfig) GetResourceLabels() map[string]string {
	if x != nil {
		return x.ResourceLabels
	}
	return nil
}

func (x *NodeConfig) GetLocalSsdEncryptionMode() NodeConfig_LocalSsdEncryptionMode {
	if x != nil && x.LocalSsdEncryptionMode != nil {
		return *x.LocalSsdEncryptionMode
	}
	return NodeConfig_LOCAL_SSD_ENCRYPTION_MODE_UNSPECIFIED
}

func (x *NodeConfig) GetEffectiveCgroupMode() NodeConfig_EffectiveCgroupMode {
	if x != nil {
		return x.EffectiveCgroupMode
	}
	return NodeConfig_EFFECTIVE_CGROUP_MODE_UNSPECIFIED
}

// Settings for blue-green upgrade.
type BlueGreenSettings struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The rollout policy controls the general rollout progress of blue-green.
	//
	// Types that are valid to be assigned to RolloutPolicy:
	//
	//	*BlueGreenSettings_StandardRolloutPolicy_
	RolloutPolicy isBlueGreenSettings_RolloutPolicy `protobuf_oneof:"rollout_policy"`
	// Time needed after draining entire blue pool. After this period, blue pool
	// will be cleaned up.
	NodePoolSoakDuration *durationpb.Duration `protobuf:"bytes,2,opt,name=node_pool_soak_duration,json=nodePoolSoakDuration,proto3,oneof" json:"node_pool_soak_duration,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *BlueGreenSettings) Reset() {
	*x = BlueGreenSettings{}
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlueGreenSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlueGreenSettings) ProtoMessage() {}

func (x *BlueGreenSettings) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlueGreenSettings.ProtoReflect.Descriptor instead.
func (*BlueGreenSettings) Descriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{8}
}

func (x *BlueGreenSettings) GetRolloutPolicy() isBlueGreenSettings_RolloutPolicy {
	if x != nil {
		return x.RolloutPolicy
	}
	return nil
}

func (x *BlueGreenSettings) GetStandardRolloutPolicy() *BlueGreenSettings_StandardRolloutPolicy {
	if x != nil {
		if x, ok := x.RolloutPolicy.(*BlueGreenSettings_StandardRolloutPolicy_); ok {
			return x.StandardRolloutPolicy
		}
	}
	return nil
}

func (x *BlueGreenSettings) GetNodePoolSoakDuration() *durationpb.Duration {
	if x != nil {
		return x.NodePoolSoakDuration
	}
	return nil
}

type isBlueGreenSettings_RolloutPolicy interface {
	isBlueGreenSettings_RolloutPolicy()
}

type BlueGreenSettings_StandardRolloutPolicy_ struct {
	// Standard policy for the blue-green upgrade.
	StandardRolloutPolicy *BlueGreenSettings_StandardRolloutPolicy `protobuf:"bytes,1,opt,name=standard_rollout_policy,json=standardRolloutPolicy,proto3,oneof"`
}

func (*BlueGreenSettings_StandardRolloutPolicy_) isBlueGreenSettings_RolloutPolicy() {}

type GKENodePool struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the node pool.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The node configuration of the pool.
	Config *NodeConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	// The initial node count for the pool. You must ensure that your
	// Compute Engine [resource quota](https://cloud.google.com/compute/quotas)
	// is sufficient for this number of instances. You must also have available
	// firewall and routes quota.
	InitialNodeCount int32 `protobuf:"varint,3,opt,name=initial_node_count,json=initialNodeCount,proto3" json:"initial_node_count,omitempty"`
	// The list of Google Compute Engine
	// [zones](https://cloud.google.com/compute/docs/zones#available) in which the
	// NodePool's nodes should be located.
	//
	// If this value is unspecified during node pool creation, the
	// [Cluster.Locations](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters#Cluster.FIELDS.locations)
	// value will be used, instead.
	//
	// Warning: changing node pool locations will result in nodes being added
	// and/or removed.
	Locations []string `protobuf:"bytes,13,rep,name=locations,proto3" json:"locations,omitempty"`
	// Output only. Server-defined URL for the resource.
	SelfLink string `protobuf:"bytes,100,opt,name=self_link,json=selfLink,proto3" json:"self_link,omitempty"`
	// The version of Kubernetes running on this NodePool's nodes. If unspecified,
	// it defaults as described
	// [here](https://cloud.google.com/kubernetes-engine/versioning#specifying_node_version).
	Version string `protobuf:"bytes,101,opt,name=version,proto3" json:"version,omitempty"`
	// Output only. The resource URLs of the [managed instance
	// groups](https://cloud.google.com/compute/docs/instance-groups/creating-groups-of-managed-instances)
	// associated with this node pool.
	// During the node pool blue-green upgrade operation, the URLs contain both
	// blue and green resources.
	InstanceGroupUrls []string `protobuf:"bytes,102,rep,name=instance_group_urls,json=instanceGroupUrls,proto3" json:"instance_group_urls,omitempty"`
	// Output only. The status of the nodes in this pool instance.
	Status GKENodePool_Status `protobuf:"varint,103,opt,name=status,proto3,enum=chalk.nodepools.v1.GKENodePool_Status" json:"status,omitempty"`
	// Output only. Deprecated. Use conditions instead.
	// Additional information about the current status of this
	// node pool instance, if available.
	//
	// Deprecated: Marked as deprecated in chalk/nodepools/v1/gke.proto.
	StatusMessage string `protobuf:"bytes,104,opt,name=status_message,json=statusMessage,proto3" json:"status_message,omitempty"`
	// Autoscaler configuration for this NodePool. Autoscaler is enabled
	// only if a valid configuration is present.
	Autoscaling *NodePoolAutoscaling `protobuf:"bytes,4,opt,name=autoscaling,proto3" json:"autoscaling,omitempty"`
	// NodeManagement configuration for this NodePool.
	Management *NodeManagement `protobuf:"bytes,5,opt,name=management,proto3" json:"management,omitempty"`
	// The constraint on the maximum number of pods that can be run
	// simultaneously on a node in the node pool.
	MaxPodsConstraint *MaxPodsConstraint `protobuf:"bytes,6,opt,name=max_pods_constraint,json=maxPodsConstraint,proto3" json:"max_pods_constraint,omitempty"`
	// Which conditions caused the current node pool state.
	Conditions []*StatusCondition `protobuf:"bytes,105,rep,name=conditions,proto3" json:"conditions,omitempty"`
	// Output only. The pod CIDR block size per node in this node pool.
	PodIpv4CidrSize int32 `protobuf:"varint,7,opt,name=pod_ipv4_cidr_size,json=podIpv4CidrSize,proto3" json:"pod_ipv4_cidr_size,omitempty"`
	// Upgrade settings control disruption and speed of the upgrade.
	UpgradeSettings *GKENodePool_UpgradeSettings `protobuf:"bytes,107,opt,name=upgrade_settings,json=upgradeSettings,proto3" json:"upgrade_settings,omitempty"`
	// Specifies the node placement policy.
	PlacementPolicy *GKENodePool_PlacementPolicy `protobuf:"bytes,108,opt,name=placement_policy,json=placementPolicy,proto3" json:"placement_policy,omitempty"`
	// Output only. Update info contains relevant information during a node
	// pool update.
	UpdateInfo *GKENodePool_UpdateInfo `protobuf:"bytes,109,opt,name=update_info,json=updateInfo,proto3" json:"update_info,omitempty"`
	// This checksum is computed by the server based on the value of node pool
	// fields, and may be sent on update requests to ensure the client has an
	// up-to-date value before proceeding.
	Etag string `protobuf:"bytes,110,opt,name=etag,proto3" json:"etag,omitempty"`
	// Specifies the configuration of queued provisioning.
	QueuedProvisioning *GKENodePool_QueuedProvisioning `protobuf:"bytes,112,opt,name=queued_provisioning,json=queuedProvisioning,proto3" json:"queued_provisioning,omitempty"`
	// Enable best effort provisioning for nodes
	BestEffortProvisioning *BestEffortProvisioning `protobuf:"bytes,113,opt,name=best_effort_provisioning,json=bestEffortProvisioning,proto3" json:"best_effort_provisioning,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *GKENodePool) Reset() {
	*x = GKENodePool{}
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GKENodePool) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GKENodePool) ProtoMessage() {}

func (x *GKENodePool) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GKENodePool.ProtoReflect.Descriptor instead.
func (*GKENodePool) Descriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{9}
}

func (x *GKENodePool) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GKENodePool) GetConfig() *NodeConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *GKENodePool) GetInitialNodeCount() int32 {
	if x != nil {
		return x.InitialNodeCount
	}
	return 0
}

func (x *GKENodePool) GetLocations() []string {
	if x != nil {
		return x.Locations
	}
	return nil
}

func (x *GKENodePool) GetSelfLink() string {
	if x != nil {
		return x.SelfLink
	}
	return ""
}

func (x *GKENodePool) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *GKENodePool) GetInstanceGroupUrls() []string {
	if x != nil {
		return x.InstanceGroupUrls
	}
	return nil
}

func (x *GKENodePool) GetStatus() GKENodePool_Status {
	if x != nil {
		return x.Status
	}
	return GKENodePool_STATUS_UNSPECIFIED
}

// Deprecated: Marked as deprecated in chalk/nodepools/v1/gke.proto.
func (x *GKENodePool) GetStatusMessage() string {
	if x != nil {
		return x.StatusMessage
	}
	return ""
}

func (x *GKENodePool) GetAutoscaling() *NodePoolAutoscaling {
	if x != nil {
		return x.Autoscaling
	}
	return nil
}

func (x *GKENodePool) GetManagement() *NodeManagement {
	if x != nil {
		return x.Management
	}
	return nil
}

func (x *GKENodePool) GetMaxPodsConstraint() *MaxPodsConstraint {
	if x != nil {
		return x.MaxPodsConstraint
	}
	return nil
}

func (x *GKENodePool) GetConditions() []*StatusCondition {
	if x != nil {
		return x.Conditions
	}
	return nil
}

func (x *GKENodePool) GetPodIpv4CidrSize() int32 {
	if x != nil {
		return x.PodIpv4CidrSize
	}
	return 0
}

func (x *GKENodePool) GetUpgradeSettings() *GKENodePool_UpgradeSettings {
	if x != nil {
		return x.UpgradeSettings
	}
	return nil
}

func (x *GKENodePool) GetPlacementPolicy() *GKENodePool_PlacementPolicy {
	if x != nil {
		return x.PlacementPolicy
	}
	return nil
}

func (x *GKENodePool) GetUpdateInfo() *GKENodePool_UpdateInfo {
	if x != nil {
		return x.UpdateInfo
	}
	return nil
}

func (x *GKENodePool) GetEtag() string {
	if x != nil {
		return x.Etag
	}
	return ""
}

func (x *GKENodePool) GetQueuedProvisioning() *GKENodePool_QueuedProvisioning {
	if x != nil {
		return x.QueuedProvisioning
	}
	return nil
}

func (x *GKENodePool) GetBestEffortProvisioning() *BestEffortProvisioning {
	if x != nil {
		return x.BestEffortProvisioning
	}
	return nil
}

// Standard rollout policy is the default policy for blue-green.
type BlueGreenSettings_StandardRolloutPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Blue pool size to drain in a batch.
	//
	// Types that are valid to be assigned to UpdateBatchSize:
	//
	//	*BlueGreenSettings_StandardRolloutPolicy_BatchPercentage
	//	*BlueGreenSettings_StandardRolloutPolicy_BatchNodeCount
	UpdateBatchSize isBlueGreenSettings_StandardRolloutPolicy_UpdateBatchSize `protobuf_oneof:"update_batch_size"`
	// Soak time after each batch gets drained. Default to zero.
	BatchSoakDuration *durationpb.Duration `protobuf:"bytes,3,opt,name=batch_soak_duration,json=batchSoakDuration,proto3,oneof" json:"batch_soak_duration,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *BlueGreenSettings_StandardRolloutPolicy) Reset() {
	*x = BlueGreenSettings_StandardRolloutPolicy{}
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlueGreenSettings_StandardRolloutPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlueGreenSettings_StandardRolloutPolicy) ProtoMessage() {}

func (x *BlueGreenSettings_StandardRolloutPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlueGreenSettings_StandardRolloutPolicy.ProtoReflect.Descriptor instead.
func (*BlueGreenSettings_StandardRolloutPolicy) Descriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{8, 0}
}

func (x *BlueGreenSettings_StandardRolloutPolicy) GetUpdateBatchSize() isBlueGreenSettings_StandardRolloutPolicy_UpdateBatchSize {
	if x != nil {
		return x.UpdateBatchSize
	}
	return nil
}

func (x *BlueGreenSettings_StandardRolloutPolicy) GetBatchPercentage() float32 {
	if x != nil {
		if x, ok := x.UpdateBatchSize.(*BlueGreenSettings_StandardRolloutPolicy_BatchPercentage); ok {
			return x.BatchPercentage
		}
	}
	return 0
}

func (x *BlueGreenSettings_StandardRolloutPolicy) GetBatchNodeCount() int32 {
	if x != nil {
		if x, ok := x.UpdateBatchSize.(*BlueGreenSettings_StandardRolloutPolicy_BatchNodeCount); ok {
			return x.BatchNodeCount
		}
	}
	return 0
}

func (x *BlueGreenSettings_StandardRolloutPolicy) GetBatchSoakDuration() *durationpb.Duration {
	if x != nil {
		return x.BatchSoakDuration
	}
	return nil
}

type isBlueGreenSettings_StandardRolloutPolicy_UpdateBatchSize interface {
	isBlueGreenSettings_StandardRolloutPolicy_UpdateBatchSize()
}

type BlueGreenSettings_StandardRolloutPolicy_BatchPercentage struct {
	// Percentage of the blue pool nodes to drain in a batch.
	// The range of this field should be (0.0, 1.0].
	BatchPercentage float32 `protobuf:"fixed32,1,opt,name=batch_percentage,json=batchPercentage,proto3,oneof"`
}

type BlueGreenSettings_StandardRolloutPolicy_BatchNodeCount struct {
	// Number of blue nodes to drain in a batch.
	BatchNodeCount int32 `protobuf:"varint,2,opt,name=batch_node_count,json=batchNodeCount,proto3,oneof"`
}

func (*BlueGreenSettings_StandardRolloutPolicy_BatchPercentage) isBlueGreenSettings_StandardRolloutPolicy_UpdateBatchSize() {
}

func (*BlueGreenSettings_StandardRolloutPolicy_BatchNodeCount) isBlueGreenSettings_StandardRolloutPolicy_UpdateBatchSize() {
}

type GKENodePool_UpgradeSettings struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum number of nodes that can be created beyond the current size
	// of the node pool during the upgrade process.
	MaxSurge int32 `protobuf:"varint,1,opt,name=max_surge,json=maxSurge,proto3" json:"max_surge,omitempty"`
	// The maximum number of nodes that can be simultaneously unavailable during
	// the upgrade process. A node is considered available if its status is
	// Ready.
	MaxUnavailable int32 `protobuf:"varint,2,opt,name=max_unavailable,json=maxUnavailable,proto3" json:"max_unavailable,omitempty"`
	// Update strategy of the node pool.
	Strategy *NodePoolUpdateStrategy `protobuf:"varint,3,opt,name=strategy,proto3,enum=chalk.nodepools.v1.NodePoolUpdateStrategy,oneof" json:"strategy,omitempty"`
	// Settings for blue-green upgrade strategy.
	BlueGreenSettings *BlueGreenSettings `protobuf:"bytes,4,opt,name=blue_green_settings,json=blueGreenSettings,proto3,oneof" json:"blue_green_settings,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *GKENodePool_UpgradeSettings) Reset() {
	*x = GKENodePool_UpgradeSettings{}
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GKENodePool_UpgradeSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GKENodePool_UpgradeSettings) ProtoMessage() {}

func (x *GKENodePool_UpgradeSettings) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GKENodePool_UpgradeSettings.ProtoReflect.Descriptor instead.
func (*GKENodePool_UpgradeSettings) Descriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{9, 0}
}

func (x *GKENodePool_UpgradeSettings) GetMaxSurge() int32 {
	if x != nil {
		return x.MaxSurge
	}
	return 0
}

func (x *GKENodePool_UpgradeSettings) GetMaxUnavailable() int32 {
	if x != nil {
		return x.MaxUnavailable
	}
	return 0
}

func (x *GKENodePool_UpgradeSettings) GetStrategy() NodePoolUpdateStrategy {
	if x != nil && x.Strategy != nil {
		return *x.Strategy
	}
	return NodePoolUpdateStrategy_NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED
}

func (x *GKENodePool_UpgradeSettings) GetBlueGreenSettings() *BlueGreenSettings {
	if x != nil {
		return x.BlueGreenSettings
	}
	return nil
}

// UpdateInfo contains resource (instance groups, etc), status and other
// intermediate information relevant to a node pool upgrade.
type GKENodePool_UpdateInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Information of a blue-green upgrade.
	BlueGreenInfo *GKENodePool_UpdateInfo_BlueGreenInfo `protobuf:"bytes,1,opt,name=blue_green_info,json=blueGreenInfo,proto3" json:"blue_green_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GKENodePool_UpdateInfo) Reset() {
	*x = GKENodePool_UpdateInfo{}
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GKENodePool_UpdateInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GKENodePool_UpdateInfo) ProtoMessage() {}

func (x *GKENodePool_UpdateInfo) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GKENodePool_UpdateInfo.ProtoReflect.Descriptor instead.
func (*GKENodePool_UpdateInfo) Descriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{9, 1}
}

func (x *GKENodePool_UpdateInfo) GetBlueGreenInfo() *GKENodePool_UpdateInfo_BlueGreenInfo {
	if x != nil {
		return x.BlueGreenInfo
	}
	return nil
}

// PlacementPolicy defines the placement policy used by the node pool.
type GKENodePool_PlacementPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of placement.
	Type GKENodePool_PlacementPolicy_Type `protobuf:"varint,1,opt,name=type,proto3,enum=chalk.nodepools.v1.GKENodePool_PlacementPolicy_Type" json:"type,omitempty"`
	// Optional. TPU placement topology for pod slice node pool.
	// https://cloud.google.com/tpu/docs/types-topologies#tpu_topologies
	TpuTopology string `protobuf:"bytes,2,opt,name=tpu_topology,json=tpuTopology,proto3" json:"tpu_topology,omitempty"`
	// If set, refers to the name of a custom resource policy supplied by the
	// user. The resource policy must be in the same project and region as the
	// node pool. If not found, InvalidArgument error is returned.
	PolicyName    string `protobuf:"bytes,3,opt,name=policy_name,json=policyName,proto3" json:"policy_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GKENodePool_PlacementPolicy) Reset() {
	*x = GKENodePool_PlacementPolicy{}
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GKENodePool_PlacementPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GKENodePool_PlacementPolicy) ProtoMessage() {}

func (x *GKENodePool_PlacementPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GKENodePool_PlacementPolicy.ProtoReflect.Descriptor instead.
func (*GKENodePool_PlacementPolicy) Descriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{9, 2}
}

func (x *GKENodePool_PlacementPolicy) GetType() GKENodePool_PlacementPolicy_Type {
	if x != nil {
		return x.Type
	}
	return GKENodePool_PlacementPolicy_TYPE_UNSPECIFIED
}

func (x *GKENodePool_PlacementPolicy) GetTpuTopology() string {
	if x != nil {
		return x.TpuTopology
	}
	return ""
}

func (x *GKENodePool_PlacementPolicy) GetPolicyName() string {
	if x != nil {
		return x.PolicyName
	}
	return ""
}

// QueuedProvisioning defines the queued provisioning used by the node pool.
type GKENodePool_QueuedProvisioning struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Denotes that this nodepool is QRM specific, meaning nodes can be only
	// obtained through queuing via the Cluster Autoscaler ProvisioningRequest
	// API.
	Enabled       bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GKENodePool_QueuedProvisioning) Reset() {
	*x = GKENodePool_QueuedProvisioning{}
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GKENodePool_QueuedProvisioning) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GKENodePool_QueuedProvisioning) ProtoMessage() {}

func (x *GKENodePool_QueuedProvisioning) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GKENodePool_QueuedProvisioning.ProtoReflect.Descriptor instead.
func (*GKENodePool_QueuedProvisioning) Descriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{9, 3}
}

func (x *GKENodePool_QueuedProvisioning) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

// Information relevant to blue-green upgrade.
type GKENodePool_UpdateInfo_BlueGreenInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Current blue-green upgrade phase.
	Phase GKENodePool_UpdateInfo_BlueGreenInfo_Phase `protobuf:"varint,1,opt,name=phase,proto3,enum=chalk.nodepools.v1.GKENodePool_UpdateInfo_BlueGreenInfo_Phase" json:"phase,omitempty"`
	// The resource URLs of the [managed instance groups]
	// (/compute/docs/instance-groups/creating-groups-of-managed-instances)
	// associated with blue pool.
	BlueInstanceGroupUrls []string `protobuf:"bytes,2,rep,name=blue_instance_group_urls,json=blueInstanceGroupUrls,proto3" json:"blue_instance_group_urls,omitempty"`
	// The resource URLs of the [managed instance groups]
	// (/compute/docs/instance-groups/creating-groups-of-managed-instances)
	// associated with green pool.
	GreenInstanceGroupUrls []string `protobuf:"bytes,3,rep,name=green_instance_group_urls,json=greenInstanceGroupUrls,proto3" json:"green_instance_group_urls,omitempty"`
	// Time to start deleting blue pool to complete blue-green upgrade,
	// in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
	BluePoolDeletionStartTime string `protobuf:"bytes,4,opt,name=blue_pool_deletion_start_time,json=bluePoolDeletionStartTime,proto3" json:"blue_pool_deletion_start_time,omitempty"`
	// Version of green pool.
	GreenPoolVersion string `protobuf:"bytes,5,opt,name=green_pool_version,json=greenPoolVersion,proto3" json:"green_pool_version,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *GKENodePool_UpdateInfo_BlueGreenInfo) Reset() {
	*x = GKENodePool_UpdateInfo_BlueGreenInfo{}
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GKENodePool_UpdateInfo_BlueGreenInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GKENodePool_UpdateInfo_BlueGreenInfo) ProtoMessage() {}

func (x *GKENodePool_UpdateInfo_BlueGreenInfo) ProtoReflect() protoreflect.Message {
	mi := &file_chalk_nodepools_v1_gke_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GKENodePool_UpdateInfo_BlueGreenInfo.ProtoReflect.Descriptor instead.
func (*GKENodePool_UpdateInfo_BlueGreenInfo) Descriptor() ([]byte, []int) {
	return file_chalk_nodepools_v1_gke_proto_rawDescGZIP(), []int{9, 1, 0}
}

func (x *GKENodePool_UpdateInfo_BlueGreenInfo) GetPhase() GKENodePool_UpdateInfo_BlueGreenInfo_Phase {
	if x != nil {
		return x.Phase
	}
	return GKENodePool_UpdateInfo_BlueGreenInfo_PHASE_UNSPECIFIED
}

func (x *GKENodePool_UpdateInfo_BlueGreenInfo) GetBlueInstanceGroupUrls() []string {
	if x != nil {
		return x.BlueInstanceGroupUrls
	}
	return nil
}

func (x *GKENodePool_UpdateInfo_BlueGreenInfo) GetGreenInstanceGroupUrls() []string {
	if x != nil {
		return x.GreenInstanceGroupUrls
	}
	return nil
}

func (x *GKENodePool_UpdateInfo_BlueGreenInfo) GetBluePoolDeletionStartTime() string {
	if x != nil {
		return x.BluePoolDeletionStartTime
	}
	return ""
}

func (x *GKENodePool_UpdateInfo_BlueGreenInfo) GetGreenPoolVersion() string {
	if x != nil {
		return x.GreenPoolVersion
	}
	return ""
}

var File_chalk_nodepools_v1_gke_proto protoreflect.FileDescriptor

const file_chalk_nodepools_v1_gke_proto_rawDesc = "" +
	"\n" +
	"\x1cchalk/nodepools/v1/gke.proto\x12\x12chalk.nodepools.v1\x1a\x1egoogle/protobuf/duration.proto\x1a\x15google/rpc/code.proto\"\xa0\x03\n" +
	"\x0fStatusCondition\x12@\n" +
	"\x04code\x18\x01 \x01(\x0e2(.chalk.nodepools.v1.StatusCondition.CodeB\x02\x18\x01R\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x127\n" +
	"\x0ecanonical_code\x18\x03 \x01(\x0e2\x10.google.rpc.CodeR\rcanonicalCode\"\xf7\x01\n" +
	"\x04Code\x12\x14\n" +
	"\x10CODE_UNSPECIFIED\x10\x00\x12\x15\n" +
	"\x11CODE_GCE_STOCKOUT\x10\x01\x12$\n" +
	" CODE_GKE_SERVICE_ACCOUNT_DELETED\x10\x02\x12\x1b\n" +
	"\x17CODE_GCE_QUOTA_EXCEEDED\x10\x03\x12\x18\n" +
	"\x14CODE_SET_BY_OPERATOR\x10\x04\x12\x1c\n" +
	"\x18CODE_CLOUD_KMS_KEY_ERROR\x10\a\x12\x14\n" +
	"\x10CODE_CA_EXPIRING\x10\t\x121\n" +
	"-CODE_NODE_SERVICE_ACCOUNT_MISSING_PERMISSIONS\x10\n" +
	"\"\xd2\x03\n" +
	"\x13NodePoolAutoscaling\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12$\n" +
	"\x0emin_node_count\x18\x02 \x01(\x05R\fminNodeCount\x12$\n" +
	"\x0emax_node_count\x18\x03 \x01(\x05R\fmaxNodeCount\x12(\n" +
	"\x0fautoprovisioned\x18\x04 \x01(\bR\x0fautoprovisioned\x12_\n" +
	"\x0flocation_policy\x18\x05 \x01(\x0e26.chalk.nodepools.v1.NodePoolAutoscaling.LocationPolicyR\x0elocationPolicy\x12/\n" +
	"\x14total_min_node_count\x18\x06 \x01(\x05R\x11totalMinNodeCount\x12/\n" +
	"\x14total_max_node_count\x18\a \x01(\x05R\x11totalMaxNodeCount\"h\n" +
	"\x0eLocationPolicy\x12\x1f\n" +
	"\x1bLOCATION_POLICY_UNSPECIFIED\x10\x00\x12\x1c\n" +
	"\x18LOCATION_POLICY_BALANCED\x10\x01\x12\x17\n" +
	"\x13LOCATION_POLICY_ANY\x10\x02\"\xe1\x01\n" +
	"\tNodeTaint\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\x12<\n" +
	"\x06effect\x18\x03 \x01(\x0e2$.chalk.nodepools.v1.NodeTaint.EffectR\x06effect\"n\n" +
	"\x06Effect\x12\x16\n" +
	"\x12EFFECT_UNSPECIFIED\x10\x00\x12\x16\n" +
	"\x12EFFECT_NO_SCHEDULE\x10\x01\x12\x1d\n" +
	"\x19EFFECT_PREFER_NO_SCHEDULE\x10\x02\x12\x15\n" +
	"\x11EFFECT_NO_EXECUTE\x10\x03\">\n" +
	"\x11MaxPodsConstraint\x12)\n" +
	"\x11max_pods_per_node\x18\x01 \x01(\x03R\x0emaxPodsPerNode\"b\n" +
	"\x16BestEffortProvisioning\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12.\n" +
	"\x13min_provision_nodes\x18\x02 \x01(\x05R\x11minProvisionNodes\"\xa5\x01\n" +
	"\x0eNodeManagement\x12!\n" +
	"\fauto_upgrade\x18\x01 \x01(\bR\vautoUpgrade\x12\x1f\n" +
	"\vauto_repair\x18\x02 \x01(\bR\n" +
	"autoRepair\x12O\n" +
	"\x0fupgrade_options\x18\n" +
	" \x01(\v2&.chalk.nodepools.v1.AutoUpgradeOptionsR\x0eupgradeOptions\"m\n" +
	"\x12AutoUpgradeOptions\x125\n" +
	"\x17auto_upgrade_start_time\x18\x01 \x01(\tR\x14autoUpgradeStartTime\x12 \n" +
	"\vdescription\x18\x02 \x01(\tR\vdescription\"\xc4\v\n" +
	"\n" +
	"NodeConfig\x12!\n" +
	"\fmachine_type\x18\x01 \x01(\tR\vmachineType\x12 \n" +
	"\fdisk_size_gb\x18\x02 \x01(\x05R\n" +
	"diskSizeGb\x12!\n" +
	"\foauth_scopes\x18\x03 \x03(\tR\voauthScopes\x12'\n" +
	"\x0fservice_account\x18\t \x01(\tR\x0eserviceAccount\x12H\n" +
	"\bmetadata\x18\x04 \x03(\v2,.chalk.nodepools.v1.NodeConfig.MetadataEntryR\bmetadata\x12\x1d\n" +
	"\n" +
	"image_type\x18\x05 \x01(\tR\timageType\x12B\n" +
	"\x06labels\x18\x06 \x03(\v2*.chalk.nodepools.v1.NodeConfig.LabelsEntryR\x06labels\x12&\n" +
	"\x0flocal_ssd_count\x18\a \x01(\x05R\rlocalSsdCount\x12\x12\n" +
	"\x04tags\x18\b \x03(\tR\x04tags\x12 \n" +
	"\vpreemptible\x18\n" +
	" \x01(\bR\vpreemptible\x12\x1b\n" +
	"\tdisk_type\x18\f \x01(\tR\bdiskType\x12(\n" +
	"\x10min_cpu_platform\x18\r \x01(\tR\x0eminCpuPlatform\x125\n" +
	"\x06taints\x18\x0f \x03(\v2\x1d.chalk.nodepools.v1.NodeTaintR\x06taints\x12\x1d\n" +
	"\n" +
	"node_group\x18\x12 \x01(\tR\tnodeGroup\x12)\n" +
	"\x11boot_disk_kms_key\x18\x17 \x01(\tR\x0ebootDiskKmsKey\x12\x12\n" +
	"\x04spot\x18  \x01(\bR\x04spot\x12[\n" +
	"\x0fresource_labels\x18% \x03(\v22.chalk.nodepools.v1.NodeConfig.ResourceLabelsEntryR\x0eresourceLabels\x12u\n" +
	"\x19local_ssd_encryption_mode\x186 \x01(\x0e25.chalk.nodepools.v1.NodeConfig.LocalSsdEncryptionModeH\x00R\x16localSsdEncryptionMode\x88\x01\x01\x12f\n" +
	"\x15effective_cgroup_mode\x187 \x01(\x0e22.chalk.nodepools.v1.NodeConfig.EffectiveCgroupModeR\x13effectiveCgroupMode\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1aA\n" +
	"\x13ResourceLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xae\x01\n" +
	"\x16LocalSsdEncryptionMode\x12)\n" +
	"%LOCAL_SSD_ENCRYPTION_MODE_UNSPECIFIED\x10\x00\x121\n" +
	"-LOCAL_SSD_ENCRYPTION_MODE_STANDARD_ENCRYPTION\x10\x01\x126\n" +
	"2LOCAL_SSD_ENCRYPTION_MODE_EPHEMERAL_KEY_ENCRYPTION\x10\x02\"x\n" +
	"\x13EffectiveCgroupMode\x12%\n" +
	"!EFFECTIVE_CGROUP_MODE_UNSPECIFIED\x10\x00\x12\x1c\n" +
	"\x18EFFECTIVE_CGROUP_MODE_V1\x10\x01\x12\x1c\n" +
	"\x18EFFECTIVE_CGROUP_MODE_V2\x10\x02B\x1c\n" +
	"\x1a_local_ssd_encryption_mode\"\xff\x03\n" +
	"\x11BlueGreenSettings\x12u\n" +
	"\x17standard_rollout_policy\x18\x01 \x01(\v2;.chalk.nodepools.v1.BlueGreenSettings.StandardRolloutPolicyH\x00R\x15standardRolloutPolicy\x12U\n" +
	"\x17node_pool_soak_duration\x18\x02 \x01(\v2\x19.google.protobuf.DurationH\x01R\x14nodePoolSoakDuration\x88\x01\x01\x1a\xed\x01\n" +
	"\x15StandardRolloutPolicy\x12+\n" +
	"\x10batch_percentage\x18\x01 \x01(\x02H\x00R\x0fbatchPercentage\x12*\n" +
	"\x10batch_node_count\x18\x02 \x01(\x05H\x00R\x0ebatchNodeCount\x12N\n" +
	"\x13batch_soak_duration\x18\x03 \x01(\v2\x19.google.protobuf.DurationH\x01R\x11batchSoakDuration\x88\x01\x01B\x13\n" +
	"\x11update_batch_sizeB\x16\n" +
	"\x14_batch_soak_durationB\x10\n" +
	"\x0erollout_policyB\x1a\n" +
	"\x18_node_pool_soak_duration\"\xb6\x14\n" +
	"\vGKENodePool\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x126\n" +
	"\x06config\x18\x02 \x01(\v2\x1e.chalk.nodepools.v1.NodeConfigR\x06config\x12,\n" +
	"\x12initial_node_count\x18\x03 \x01(\x05R\x10initialNodeCount\x12\x1c\n" +
	"\tlocations\x18\r \x03(\tR\tlocations\x12\x1b\n" +
	"\tself_link\x18d \x01(\tR\bselfLink\x12\x18\n" +
	"\aversion\x18e \x01(\tR\aversion\x12.\n" +
	"\x13instance_group_urls\x18f \x03(\tR\x11instanceGroupUrls\x12>\n" +
	"\x06status\x18g \x01(\x0e2&.chalk.nodepools.v1.GKENodePool.StatusR\x06status\x12)\n" +
	"\x0estatus_message\x18h \x01(\tB\x02\x18\x01R\rstatusMessage\x12I\n" +
	"\vautoscaling\x18\x04 \x01(\v2'.chalk.nodepools.v1.NodePoolAutoscalingR\vautoscaling\x12B\n" +
	"\n" +
	"management\x18\x05 \x01(\v2\".chalk.nodepools.v1.NodeManagementR\n" +
	"management\x12U\n" +
	"\x13max_pods_constraint\x18\x06 \x01(\v2%.chalk.nodepools.v1.MaxPodsConstraintR\x11maxPodsConstraint\x12C\n" +
	"\n" +
	"conditions\x18i \x03(\v2#.chalk.nodepools.v1.StatusConditionR\n" +
	"conditions\x12+\n" +
	"\x12pod_ipv4_cidr_size\x18\a \x01(\x05R\x0fpodIpv4CidrSize\x12Z\n" +
	"\x10upgrade_settings\x18k \x01(\v2/.chalk.nodepools.v1.GKENodePool.UpgradeSettingsR\x0fupgradeSettings\x12Z\n" +
	"\x10placement_policy\x18l \x01(\v2/.chalk.nodepools.v1.GKENodePool.PlacementPolicyR\x0fplacementPolicy\x12K\n" +
	"\vupdate_info\x18m \x01(\v2*.chalk.nodepools.v1.GKENodePool.UpdateInfoR\n" +
	"updateInfo\x12\x12\n" +
	"\x04etag\x18n \x01(\tR\x04etag\x12c\n" +
	"\x13queued_provisioning\x18p \x01(\v22.chalk.nodepools.v1.GKENodePool.QueuedProvisioningR\x12queuedProvisioning\x12d\n" +
	"\x18best_effort_provisioning\x18q \x01(\v2*.chalk.nodepools.v1.BestEffortProvisioningR\x16bestEffortProvisioning\x1a\xa5\x02\n" +
	"\x0fUpgradeSettings\x12\x1b\n" +
	"\tmax_surge\x18\x01 \x01(\x05R\bmaxSurge\x12'\n" +
	"\x0fmax_unavailable\x18\x02 \x01(\x05R\x0emaxUnavailable\x12K\n" +
	"\bstrategy\x18\x03 \x01(\x0e2*.chalk.nodepools.v1.NodePoolUpdateStrategyH\x00R\bstrategy\x88\x01\x01\x12Z\n" +
	"\x13blue_green_settings\x18\x04 \x01(\v2%.chalk.nodepools.v1.BlueGreenSettingsH\x01R\x11blueGreenSettings\x88\x01\x01B\v\n" +
	"\t_strategyB\x16\n" +
	"\x14_blue_green_settings\x1a\xa8\x05\n" +
	"\n" +
	"UpdateInfo\x12`\n" +
	"\x0fblue_green_info\x18\x01 \x01(\v28.chalk.nodepools.v1.GKENodePool.UpdateInfo.BlueGreenInfoR\rblueGreenInfo\x1a\xb7\x04\n" +
	"\rBlueGreenInfo\x12T\n" +
	"\x05phase\x18\x01 \x01(\x0e2>.chalk.nodepools.v1.GKENodePool.UpdateInfo.BlueGreenInfo.PhaseR\x05phase\x127\n" +
	"\x18blue_instance_group_urls\x18\x02 \x03(\tR\x15blueInstanceGroupUrls\x129\n" +
	"\x19green_instance_group_urls\x18\x03 \x03(\tR\x16greenInstanceGroupUrls\x12@\n" +
	"\x1dblue_pool_deletion_start_time\x18\x04 \x01(\tR\x19bluePoolDeletionStartTime\x12,\n" +
	"\x12green_pool_version\x18\x05 \x01(\tR\x10greenPoolVersion\"\xeb\x01\n" +
	"\x05Phase\x12\x15\n" +
	"\x11PHASE_UNSPECIFIED\x10\x00\x12\x18\n" +
	"\x14PHASE_UPDATE_STARTED\x10\x01\x12\x1d\n" +
	"\x19PHASE_CREATING_GREEN_POOL\x10\x02\x12\x1d\n" +
	"\x19PHASE_CORDONING_BLUE_POOL\x10\x03\x12\x1c\n" +
	"\x18PHASE_DRAINING_BLUE_POOL\x10\x04\x12\x1b\n" +
	"\x17PHASE_NODE_POOL_SOAKING\x10\x05\x12\x1c\n" +
	"\x18PHASE_DELETING_BLUE_POOL\x10\x06\x12\x1a\n" +
	"\x16PHASE_ROLLBACK_STARTED\x10\a\x1a\xcf\x01\n" +
	"\x0fPlacementPolicy\x12H\n" +
	"\x04type\x18\x01 \x01(\x0e24.chalk.nodepools.v1.GKENodePool.PlacementPolicy.TypeR\x04type\x12!\n" +
	"\ftpu_topology\x18\x02 \x01(\tR\vtpuTopology\x12\x1f\n" +
	"\vpolicy_name\x18\x03 \x01(\tR\n" +
	"policyName\".\n" +
	"\x04Type\x12\x14\n" +
	"\x10TYPE_UNSPECIFIED\x10\x00\x12\x10\n" +
	"\fTYPE_COMPACT\x10\x01\x1a.\n" +
	"\x12QueuedProvisioning\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\"\xab\x01\n" +
	"\x06Status\x12\x16\n" +
	"\x12STATUS_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13STATUS_PROVISIONING\x10\x01\x12\x12\n" +
	"\x0eSTATUS_RUNNING\x10\x02\x12\x1d\n" +
	"\x19STATUS_RUNNING_WITH_ERROR\x10\x03\x12\x16\n" +
	"\x12STATUS_RECONCILING\x10\x04\x12\x13\n" +
	"\x0fSTATUS_STOPPING\x10\x05\x12\x10\n" +
	"\fSTATUS_ERROR\x10\x06*\x92\x01\n" +
	"\x16NodePoolUpdateStrategy\x12)\n" +
	"%NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED\x10\x00\x12(\n" +
	"$NODE_POOL_UPDATE_STRATEGY_BLUE_GREEN\x10\x02\x12#\n" +
	"\x1fNODE_POOL_UPDATE_STRATEGY_SURGE\x10\x03B\xcd\x01\n" +
	"\x16com.chalk.nodepools.v1B\bGkeProtoP\x01Z?github.com/chalk-ai/chalk-go/gen/chalk/nodepools/v1;nodepoolsv1\xa2\x02\x03CNX\xaa\x02\x12Chalk.Nodepools.V1\xca\x02\x12Chalk\\Nodepools\\V1\xe2\x02\x1eChalk\\Nodepools\\V1\\GPBMetadata\xea\x02\x14Chalk::Nodepools::V1b\x06proto3"

var (
	file_chalk_nodepools_v1_gke_proto_rawDescOnce sync.Once
	file_chalk_nodepools_v1_gke_proto_rawDescData []byte
)

func file_chalk_nodepools_v1_gke_proto_rawDescGZIP() []byte {
	file_chalk_nodepools_v1_gke_proto_rawDescOnce.Do(func() {
		file_chalk_nodepools_v1_gke_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_chalk_nodepools_v1_gke_proto_rawDesc), len(file_chalk_nodepools_v1_gke_proto_rawDesc)))
	})
	return file_chalk_nodepools_v1_gke_proto_rawDescData
}

var file_chalk_nodepools_v1_gke_proto_enumTypes = make([]protoimpl.EnumInfo, 9)
var file_chalk_nodepools_v1_gke_proto_msgTypes = make([]protoimpl.MessageInfo, 19)
var file_chalk_nodepools_v1_gke_proto_goTypes = []any{
	(NodePoolUpdateStrategy)(0),                     // 0: chalk.nodepools.v1.NodePoolUpdateStrategy
	(StatusCondition_Code)(0),                       // 1: chalk.nodepools.v1.StatusCondition.Code
	(NodePoolAutoscaling_LocationPolicy)(0),         // 2: chalk.nodepools.v1.NodePoolAutoscaling.LocationPolicy
	(NodeTaint_Effect)(0),                           // 3: chalk.nodepools.v1.NodeTaint.Effect
	(NodeConfig_LocalSsdEncryptionMode)(0),          // 4: chalk.nodepools.v1.NodeConfig.LocalSsdEncryptionMode
	(NodeConfig_EffectiveCgroupMode)(0),             // 5: chalk.nodepools.v1.NodeConfig.EffectiveCgroupMode
	(GKENodePool_Status)(0),                         // 6: chalk.nodepools.v1.GKENodePool.Status
	(GKENodePool_UpdateInfo_BlueGreenInfo_Phase)(0), // 7: chalk.nodepools.v1.GKENodePool.UpdateInfo.BlueGreenInfo.Phase
	(GKENodePool_PlacementPolicy_Type)(0),           // 8: chalk.nodepools.v1.GKENodePool.PlacementPolicy.Type
	(*StatusCondition)(nil),                         // 9: chalk.nodepools.v1.StatusCondition
	(*NodePoolAutoscaling)(nil),                     // 10: chalk.nodepools.v1.NodePoolAutoscaling
	(*NodeTaint)(nil),                               // 11: chalk.nodepools.v1.NodeTaint
	(*MaxPodsConstraint)(nil),                       // 12: chalk.nodepools.v1.MaxPodsConstraint
	(*BestEffortProvisioning)(nil),                  // 13: chalk.nodepools.v1.BestEffortProvisioning
	(*NodeManagement)(nil),                          // 14: chalk.nodepools.v1.NodeManagement
	(*AutoUpgradeOptions)(nil),                      // 15: chalk.nodepools.v1.AutoUpgradeOptions
	(*NodeConfig)(nil),                              // 16: chalk.nodepools.v1.NodeConfig
	(*BlueGreenSettings)(nil),                       // 17: chalk.nodepools.v1.BlueGreenSettings
	(*GKENodePool)(nil),                             // 18: chalk.nodepools.v1.GKENodePool
	nil,                                             // 19: chalk.nodepools.v1.NodeConfig.MetadataEntry
	nil,                                             // 20: chalk.nodepools.v1.NodeConfig.LabelsEntry
	nil,                                             // 21: chalk.nodepools.v1.NodeConfig.ResourceLabelsEntry
	(*BlueGreenSettings_StandardRolloutPolicy)(nil), // 22: chalk.nodepools.v1.BlueGreenSettings.StandardRolloutPolicy
	(*GKENodePool_UpgradeSettings)(nil),             // 23: chalk.nodepools.v1.GKENodePool.UpgradeSettings
	(*GKENodePool_UpdateInfo)(nil),                  // 24: chalk.nodepools.v1.GKENodePool.UpdateInfo
	(*GKENodePool_PlacementPolicy)(nil),             // 25: chalk.nodepools.v1.GKENodePool.PlacementPolicy
	(*GKENodePool_QueuedProvisioning)(nil),          // 26: chalk.nodepools.v1.GKENodePool.QueuedProvisioning
	(*GKENodePool_UpdateInfo_BlueGreenInfo)(nil),    // 27: chalk.nodepools.v1.GKENodePool.UpdateInfo.BlueGreenInfo
	(code.Code)(0),                                  // 28: google.rpc.Code
	(*durationpb.Duration)(nil),                     // 29: google.protobuf.Duration
}
var file_chalk_nodepools_v1_gke_proto_depIdxs = []int32{
	1,  // 0: chalk.nodepools.v1.StatusCondition.code:type_name -> chalk.nodepools.v1.StatusCondition.Code
	28, // 1: chalk.nodepools.v1.StatusCondition.canonical_code:type_name -> google.rpc.Code
	2,  // 2: chalk.nodepools.v1.NodePoolAutoscaling.location_policy:type_name -> chalk.nodepools.v1.NodePoolAutoscaling.LocationPolicy
	3,  // 3: chalk.nodepools.v1.NodeTaint.effect:type_name -> chalk.nodepools.v1.NodeTaint.Effect
	15, // 4: chalk.nodepools.v1.NodeManagement.upgrade_options:type_name -> chalk.nodepools.v1.AutoUpgradeOptions
	19, // 5: chalk.nodepools.v1.NodeConfig.metadata:type_name -> chalk.nodepools.v1.NodeConfig.MetadataEntry
	20, // 6: chalk.nodepools.v1.NodeConfig.labels:type_name -> chalk.nodepools.v1.NodeConfig.LabelsEntry
	11, // 7: chalk.nodepools.v1.NodeConfig.taints:type_name -> chalk.nodepools.v1.NodeTaint
	21, // 8: chalk.nodepools.v1.NodeConfig.resource_labels:type_name -> chalk.nodepools.v1.NodeConfig.ResourceLabelsEntry
	4,  // 9: chalk.nodepools.v1.NodeConfig.local_ssd_encryption_mode:type_name -> chalk.nodepools.v1.NodeConfig.LocalSsdEncryptionMode
	5,  // 10: chalk.nodepools.v1.NodeConfig.effective_cgroup_mode:type_name -> chalk.nodepools.v1.NodeConfig.EffectiveCgroupMode
	22, // 11: chalk.nodepools.v1.BlueGreenSettings.standard_rollout_policy:type_name -> chalk.nodepools.v1.BlueGreenSettings.StandardRolloutPolicy
	29, // 12: chalk.nodepools.v1.BlueGreenSettings.node_pool_soak_duration:type_name -> google.protobuf.Duration
	16, // 13: chalk.nodepools.v1.GKENodePool.config:type_name -> chalk.nodepools.v1.NodeConfig
	6,  // 14: chalk.nodepools.v1.GKENodePool.status:type_name -> chalk.nodepools.v1.GKENodePool.Status
	10, // 15: chalk.nodepools.v1.GKENodePool.autoscaling:type_name -> chalk.nodepools.v1.NodePoolAutoscaling
	14, // 16: chalk.nodepools.v1.GKENodePool.management:type_name -> chalk.nodepools.v1.NodeManagement
	12, // 17: chalk.nodepools.v1.GKENodePool.max_pods_constraint:type_name -> chalk.nodepools.v1.MaxPodsConstraint
	9,  // 18: chalk.nodepools.v1.GKENodePool.conditions:type_name -> chalk.nodepools.v1.StatusCondition
	23, // 19: chalk.nodepools.v1.GKENodePool.upgrade_settings:type_name -> chalk.nodepools.v1.GKENodePool.UpgradeSettings
	25, // 20: chalk.nodepools.v1.GKENodePool.placement_policy:type_name -> chalk.nodepools.v1.GKENodePool.PlacementPolicy
	24, // 21: chalk.nodepools.v1.GKENodePool.update_info:type_name -> chalk.nodepools.v1.GKENodePool.UpdateInfo
	26, // 22: chalk.nodepools.v1.GKENodePool.queued_provisioning:type_name -> chalk.nodepools.v1.GKENodePool.QueuedProvisioning
	13, // 23: chalk.nodepools.v1.GKENodePool.best_effort_provisioning:type_name -> chalk.nodepools.v1.BestEffortProvisioning
	29, // 24: chalk.nodepools.v1.BlueGreenSettings.StandardRolloutPolicy.batch_soak_duration:type_name -> google.protobuf.Duration
	0,  // 25: chalk.nodepools.v1.GKENodePool.UpgradeSettings.strategy:type_name -> chalk.nodepools.v1.NodePoolUpdateStrategy
	17, // 26: chalk.nodepools.v1.GKENodePool.UpgradeSettings.blue_green_settings:type_name -> chalk.nodepools.v1.BlueGreenSettings
	27, // 27: chalk.nodepools.v1.GKENodePool.UpdateInfo.blue_green_info:type_name -> chalk.nodepools.v1.GKENodePool.UpdateInfo.BlueGreenInfo
	8,  // 28: chalk.nodepools.v1.GKENodePool.PlacementPolicy.type:type_name -> chalk.nodepools.v1.GKENodePool.PlacementPolicy.Type
	7,  // 29: chalk.nodepools.v1.GKENodePool.UpdateInfo.BlueGreenInfo.phase:type_name -> chalk.nodepools.v1.GKENodePool.UpdateInfo.BlueGreenInfo.Phase
	30, // [30:30] is the sub-list for method output_type
	30, // [30:30] is the sub-list for method input_type
	30, // [30:30] is the sub-list for extension type_name
	30, // [30:30] is the sub-list for extension extendee
	0,  // [0:30] is the sub-list for field type_name
}

func init() { file_chalk_nodepools_v1_gke_proto_init() }
func file_chalk_nodepools_v1_gke_proto_init() {
	if File_chalk_nodepools_v1_gke_proto != nil {
		return
	}
	file_chalk_nodepools_v1_gke_proto_msgTypes[7].OneofWrappers = []any{}
	file_chalk_nodepools_v1_gke_proto_msgTypes[8].OneofWrappers = []any{
		(*BlueGreenSettings_StandardRolloutPolicy_)(nil),
	}
	file_chalk_nodepools_v1_gke_proto_msgTypes[13].OneofWrappers = []any{
		(*BlueGreenSettings_StandardRolloutPolicy_BatchPercentage)(nil),
		(*BlueGreenSettings_StandardRolloutPolicy_BatchNodeCount)(nil),
	}
	file_chalk_nodepools_v1_gke_proto_msgTypes[14].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_chalk_nodepools_v1_gke_proto_rawDesc), len(file_chalk_nodepools_v1_gke_proto_rawDesc)),
			NumEnums:      9,
			NumMessages:   19,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_chalk_nodepools_v1_gke_proto_goTypes,
		DependencyIndexes: file_chalk_nodepools_v1_gke_proto_depIdxs,
		EnumInfos:         file_chalk_nodepools_v1_gke_proto_enumTypes,
		MessageInfos:      file_chalk_nodepools_v1_gke_proto_msgTypes,
	}.Build()
	File_chalk_nodepools_v1_gke_proto = out.File
	file_chalk_nodepools_v1_gke_proto_goTypes = nil
	file_chalk_nodepools_v1_gke_proto_depIdxs = nil
}
